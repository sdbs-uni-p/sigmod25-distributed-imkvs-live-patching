From d110f466e6e398ff2afc1cbf7cdce7f96bbdf330 Mon Sep 17 00:00:00 2001
From: Michael Fruth <Michael.Fruth@uni-passau.de>
Date: Tue, 19 Mar 2024 16:22:31 +0100
Subject: [PATCH] Added Live Patching

---
 src/Makefile                       |    6 +-
 src/cluster.c                      |  464 ++++++-
 src/cluster.h                      |   67 +-
 src/commands.c                     |   33 +
 src/commands/patch.json            |   26 +
 src/commands/patch_get.json        |   20 +
 src/networking.c                   |    1 +
 src/patch.c                        |    5 +
 src/server.c                       |   66 +
 src/server.h                       |    2 +
 src/wf-userland.h                  |    1 +
 src/wfpatch-userland/wf-userland.c | 1893 ++++++++++++++++++++++++++++
 src/wfpatch-userland/wf-userland.h |   75 ++
 13 files changed, 2648 insertions(+), 11 deletions(-)
 create mode 100644 src/commands/patch.json
 create mode 100644 src/commands/patch_get.json
 create mode 100644 src/patch.c
 create mode 120000 src/wf-userland.h
 create mode 100644 src/wfpatch-userland/wf-userland.c
 create mode 100644 src/wfpatch-userland/wf-userland.h

diff --git a/src/Makefile b/src/Makefile
index e4f7d9068..becd7af02 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -316,11 +316,11 @@ endif
 
 REDIS_SERVER_NAME=redis-server$(PROG_SUFFIX)
 REDIS_SENTINEL_NAME=redis-sentinel$(PROG_SUFFIX)
-REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o eval.o bio.o rio.o rand.o memtest.o syscheck.o crcspeed.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o lolwut6.o acl.o tracking.o connection.o tls.o sha256.o timeout.o setcpuaffinity.o monotonic.o mt19937-64.o resp_parser.o call_reply.o script_lua.o script.o functions.o function_lua.o commands.o
+REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o eval.o bio.o rio.o rand.o memtest.o syscheck.o crcspeed.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o lolwut6.o acl.o tracking.o connection.o tls.o sha256.o timeout.o setcpuaffinity.o monotonic.o mt19937-64.o resp_parser.o call_reply.o script_lua.o script.o functions.o function_lua.o commands.o wfpatch-userland/wf-userland.o patch.o
 REDIS_CLI_NAME=redis-cli$(PROG_SUFFIX)
-REDIS_CLI_OBJ=anet.o adlist.o dict.o redis-cli.o zmalloc.o release.o ae.o redisassert.o crcspeed.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o
+REDIS_CLI_OBJ=anet.o adlist.o dict.o redis-cli.o zmalloc.o release.o ae.o redisassert.o crcspeed.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o wfpatch-userland/wf-userland.o
 REDIS_BENCHMARK_NAME=redis-benchmark$(PROG_SUFFIX)
-REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o dict.o zmalloc.o redisassert.o release.o crcspeed.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o
+REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o dict.o zmalloc.o redisassert.o release.o crcspeed.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o wfpatch-userland/wf-userland.o
 REDIS_CHECK_RDB_NAME=redis-check-rdb$(PROG_SUFFIX)
 REDIS_CHECK_AOF_NAME=redis-check-aof$(PROG_SUFFIX)
 ALL_SOURCES=$(sort $(patsubst %.o,%.c,$(REDIS_SERVER_OBJ) $(REDIS_CLI_OBJ) $(REDIS_BENCHMARK_OBJ)))
diff --git a/src/cluster.c b/src/cluster.c
index a3929364c..782571291 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -31,6 +31,7 @@
 #include "server.h"
 #include "cluster.h"
 #include "endianconv.h"
+#include "wf-userland.h"
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -119,6 +120,16 @@ dictType clusterNodesBlackListDictType = {
         NULL                        /* allow to expand */
 };
 
+p_printBinaryChar(char value) {
+    for (int i = 0; i < 8; i++) {
+        if (value & (1UL << i))
+            fprintf(stderr, "1");
+        else
+            fprintf(stderr, "0");
+    }
+    fprintf(stderr, "\n");
+}
+
 /* -----------------------------------------------------------------------------
  * Initialization
  * -------------------------------------------------------------------------- */
@@ -995,6 +1006,17 @@ clusterNode *createClusterNode(char *nodename, int flags) {
     node->orphaned_time = 0;
     node->repl_offset_time = 0;
     node->repl_offset = 0;
+    
+    /* Live Patching */
+    node->max_patch_version = 0;
+    node->current_patch_version = 0;
+
+    memset(node->available_patches,0,sizeof(node->available_patches));
+    memset(node->patches,0,sizeof(node->patches));
+    memset(node->patch_methods,0,sizeof(node->patch_methods));
+
+    memset(node->patch_request_times,0,sizeof(node->patch_request_times));
+
     listSetFreeMethod(node->fail_reports,zfree);
     return node;
 }
@@ -1339,8 +1361,6 @@ int clusterBumpConfigEpochWithoutConsensus(void) {
  * epoch.
  *
  * BACKGROUND
- *
- * It is not possible that different slaves get the same config
  * epoch during a failover election, because the slaves need to get voted
  * by a majority. However when we perform a manual resharding of the cluster
  * the node will assign a configuration epoch to itself without to ask
@@ -1650,6 +1670,7 @@ void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
     clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);
 
     while(count--) {
+        uint16_t g_current_patch_version = ntohs(g->notused1); // We use this for the version
         uint16_t flags = ntohs(g->flags);
         clusterNode *node;
         sds ci;
@@ -1667,7 +1688,30 @@ void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
 
         /* Update our state accordingly to the gossip sections */
         node = clusterLookupNode(g->nodename, CLUSTER_NAMELEN);
+        int do_request = 0;
         if (node) {
+            // Check patch version
+            if (node != myself && node->current_patch_version < g_current_patch_version) {
+                // Gossip tells us that this node has a new version! Update it.
+                node->current_patch_version = g_current_patch_version;
+                
+                
+                // All patches are applied in order. Thus, we can also update its available patches!
+                // Thid node must contain all patches up to its current version! 
+                for (int version = 1; version <= node->current_patch_version; version++) {
+                    // Version 1 = Index 0
+                    int bit = (version - 1) % 8;
+                    int row = (version - 1) / 8;
+                    node->available_patches[row] |= (1UL << bit);
+                }
+                // We ping this node at the end, because maybe link is broken etc..
+                // And a broken link gets fixed at the end of this function :-)
+                do_request = 1;
+                
+                // Version changed and we are in sync mode. Maybe we can apply a new patch!
+                myself->flags |= CLUSTER_NODE_CHECK_PATCH_SYNC;
+            }
+           
             /* We already know this node.
                Handle failure reports, only when the sender is a master. */
             if (sender && nodeIsMaster(sender) && node != myself) {
@@ -1748,9 +1792,12 @@ void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
                 node->port = ntohs(g->port);
                 node->pport = ntohs(g->pport);
                 node->cport = ntohs(g->cport);
+                node->current_patch_version = ntohs(g->notused1);
                 clusterAddNode(node);
             }
         }
+        if (do_request)
+            p_checkForPatchesAndRequest(node);
 
         /* Next node */
         g++;
@@ -2089,6 +2136,49 @@ static clusterNode *getNodeFromLinkAndMsg(clusterLink *link, clusterMsg *hdr) {
     return sender;
 }
 
+void p_checkForPatchesAndRequest(clusterNode *node) {
+    char patches_to_request[MAX_PATCHES_ARR];
+    memset(patches_to_request,0,sizeof(patches_to_request));
+    // Pre-Initialize patches_to_request. If 0 is set, we are allowed to request for this patch.
+    // If something is set, do not send a request because we already have sent a request and the maximum
+    // time we wait for the response is not over yet.
+    for (int i = 0; i < MAX_PATCHES; i++) {
+        int row = i / 8;
+        int bit = i % 8;
+        if (myself->patch_request_times[i] == 0 || (mstime() - myself->patch_request_times[i]) > PATCH_REQUEST_DELAY) {
+            patches_to_request[row] |= (1UL << (bit));
+        }
+    }
+
+    int do_request = 0;
+    for (int i = 0; i < MAX_PATCHES_ARR; i++) {
+        // Only ask for patches for which we don't have any pending requests...
+        // Example (two examples separated by '|'):
+        //           Example 1: | Example 2:
+        // my patches:     0011 |   0001
+        // sender patches: 0001 |   0011
+        // -----------------------------
+        // XOR:            0010 |   0010
+        // NOT my patches: 1100 |   1110
+        // -----------------------------
+        // AND:            0000 |   0010
+        patches_to_request[i] &= (myself->available_patches[i] ^ node->available_patches[i]) & (~myself->available_patches[i]);
+        
+        if (patches_to_request[i]) {
+            do_request = 1;
+            // Update patch_request_time
+            for (int j = 0; j < 8; j++) {
+                if (patches_to_request[i] & (1UL << j)) {
+                    myself->patch_request_times[(i*8) + j] = mstime();
+                    wf_log("[REDIS] [Patch Request] [%lf] [%.40s] [%.40s] [%d]\n", wf_time(), myself->name, node->name, i*8+j+1);
+                }
+            }
+        }
+    }
+    if (do_request) 
+        p_clusterSendPatchRequest(node, patches_to_request);
+}
+
 /* When this function is called, there is a packet to process starting
  * at link->rcvbuf. Releasing the buffer is up to the caller, so this
  * function should just handle the higher level stuff of processing the
@@ -2179,6 +2269,12 @@ int clusterProcessPacket(clusterLink *link) {
         explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
         explen += sizeof(clusterMsgModule) -
                 3 + ntohl(hdr->data.module.msg.len);
+    } else if (type == CLUSTERMSG_TYPE_PATCH_REQUEST) {
+        explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
+        explen += sizeof(clusterMsgPatchRequest);
+    } else if (type == CLUSTERMSG_TYPE_PATCH) {
+        explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
+        explen += sizeof(clusterMsgPatch);
     } else {
         /* We don't know this type of packet, so we assume it's well formed. */
         explen = totlen;
@@ -2191,6 +2287,25 @@ int clusterProcessPacket(clusterLink *link) {
     } 
 
     sender = getNodeFromLinkAndMsg(link, hdr);
+    
+    // Live Patching
+    if (sender) {
+
+        // Update information of sender
+        memcpy(sender->available_patches, hdr->available_patches, sizeof(sender->available_patches));
+        uint16_t sender_new_patch_version =  ntohs(hdr->current_patch_version);
+        if (sender->current_patch_version < sender_new_patch_version) {
+            sender->current_patch_version = sender_new_patch_version;
+            // Version changed. We maybe can apply a new patch?
+            myself->flags |= CLUSTER_NODE_CHECK_PATCH_SYNC;
+        }
+
+        if (type != CLUSTERMSG_TYPE_PATCH) {
+            /* Request patches. This is independent of the type.
+             * But exclue the CLUSTERMSG_TYPE_PATCH because this is the response for this request. */
+            p_checkForPatchesAndRequest(sender);
+        }
+    }
 
     /* Update the last time we saw any data from this node. We
      * use this in order to avoid detecting a timeout from a node that
@@ -2229,6 +2344,7 @@ int clusterProcessPacket(clusterLink *link) {
                 server.cluster->mf_master_offset);
         }
     }
+   
 
     /* Initial processing of PING and MEET requests replying with a PONG. */
     if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) {
@@ -2612,7 +2728,19 @@ int clusterProcessPacket(clusterLink *link) {
         uint32_t len = ntohl(hdr->data.module.msg.len);
         uint8_t type = hdr->data.module.msg.type;
         unsigned char *payload = hdr->data.module.msg.bulk_data;
-        moduleCallClusterReceivers(sender->name,module_id,type,payload,len);
+        moduleCallClusterReceivers(sender->name,module_id,type,payload,len);        
+    } else if (type == CLUSTERMSG_TYPE_PATCH_REQUEST) {
+        /* Send patches to requestor */
+        if (!sender) return 1;  /* We don't know the sender. So we cannot send patches to it! */
+        p_clusterSendPatches(sender, hdr->data.patchRequest.request.patches_to_request);
+    } else if (type == CLUSTERMSG_TYPE_PATCH) {
+        if (!sender) return 1;  /* We don't know the sender. So we don't apply its patch! */
+
+        uint16_t version = ntohs(hdr->data.patch.patch.version);
+        uint8_t method = hdr->data.patch.patch.method;
+
+        wf_log("[REDIS] [Patch Received] [%lf] [%.40s] [%.40s] [%d] [%d]\n", wf_time(), myself->name, sender->name, version, method);
+        p_setPatchVersion(version, hdr->data.patch.patch.patch, method, 0);
     } else {
         serverLog(LL_WARNING,"Received unknown packet type: %d", type);
     }
@@ -2810,6 +2938,15 @@ void clusterBroadcastMessage(void *buf, size_t len) {
     dictReleaseIterator(di);
 }
 
+void p_replicasBroadcastMessage(void *buf, size_t len) {
+    for (int i = 0; i < myself->numslaves; i++) {
+        clusterNode *slave = myself->slaves[i];
+        if (slave->flags & (CLUSTER_NODE_HANDSHAKE))
+            continue;
+        clusterSendMessage(slave->link,buf,len);
+    }
+}
+
 /* Build the message header. hdr must point to a buffer at least
  * sizeof(clusterMsg) in bytes. */
 void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
@@ -2856,6 +2993,11 @@ void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
     hdr->flags = htons(myself->flags);
     hdr->state = server.cluster->state;
 
+    // Live patching
+    memset(hdr->available_patches,0,MAX_PATCHES_ARR);
+    memcpy(hdr->available_patches,myself->available_patches,sizeof(myself->available_patches));
+    hdr->current_patch_version = htons(myself->current_patch_version);
+
     /* Set the currentEpoch and configEpochs. */
     hdr->currentEpoch = htonu64(server.cluster->currentEpoch);
     hdr->configEpoch = htonu64(master->configEpoch);
@@ -2879,6 +3021,12 @@ void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
     } else if (type == CLUSTERMSG_TYPE_UPDATE) {
         totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
         totlen += sizeof(clusterMsgDataUpdate);
+    } else if (type == CLUSTERMSG_TYPE_PATCH_REQUEST) {
+        totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
+        totlen += sizeof(clusterMsgPatchRequest);
+    } else if (type == CLUSTERMSG_TYPE_PATCH) {
+        totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
+        totlen += sizeof(clusterMsgPatch);
     }
     hdr->totlen = htonl(totlen);
     /* For PING, PONG, MEET and other variable length messages fixing the
@@ -2898,7 +3046,7 @@ void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
     gossip->cport = htons(n->cport);
     gossip->flags = htons(n->flags);
     gossip->pport = htons(n->pport);
-    gossip->notused1 = 0;
+    gossip->notused1 = htons(n->current_patch_version);
 }
 
 /* Send a PING or PONG packet to the specified node, making sure to add enough
@@ -3154,6 +3302,305 @@ void clusterSendFail(char *nodename) {
     clusterBroadcastMessage(buf,ntohl(hdr->totlen));
 }
 
+void p_clusterSendPatchRequest(clusterNode *receiver, char *patches_to_request) {
+    clusterMsg buf[1];
+    clusterMsg *hdr = (clusterMsg*) buf;
+
+    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PATCH_REQUEST);
+    memcpy(hdr->data.patchRequest.request.patches_to_request,patches_to_request,MAX_PATCHES_ARR);
+    clusterSendMessage(receiver->link,buf,ntohl(hdr->totlen));
+}
+
+void p_clusterSendPatches(clusterNode *receiver, char *patches_to_request) {
+    for (int i = 0; i < myself->max_patch_version; i++) {
+        int row = i / 8;
+        int bit = i % 8;
+        if (patches_to_request[row] & (1UL << bit))
+            // i + 1 because we set the version
+            p_clusterSendPatch(receiver, i + 1);
+    }
+}
+
+void p_clusterSendPatch(clusterNode *receiver, int version) {
+    clusterMsg buf[1];
+    clusterMsg *hdr = (clusterMsg*) buf;
+    
+    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PATCH);
+    memcpy(hdr->data.patch.patch.patch,myself->patches[version-1],MAX_PATCH_NAME_LENGTH);
+    hdr->data.patch.patch.version = htons(version);
+    hdr->data.patch.patch.method = myself->patch_methods[version-1];
+    clusterSendMessage(receiver->link,buf,ntohl(hdr->totlen));
+
+    wf_log("[REDIS] [Patch Sent] [%lf] [%.40s] [%.40s] [%d]\n", wf_time(), myself->name, receiver->name, version);
+}
+
+/*
+ * Compare two arrays of available_patches.
+ * Return 0 if they are equal
+ * Return 1 if arr1 is a subset of arr2 (arr1 < arr2)
+ * Return 2 if arr2 is a subset of arr1 (arr1 > arr2)
+ * Return -1 if they differ
+ */
+int p_compareAvailablePatches(uint8_t *arr1, uint8_t *arr2) {
+    int result = 0;
+    for (int i = 0; i < MAX_PATCHES_ARR; i++) {
+        if (arr1[i] == arr2[i]) {
+            // Equal
+        } else if ((arr1[i] & arr2[i]) == arr1[i]) {
+            // arr1 is subset of arr2
+            if (result == 2)
+                return -1; // Previous result was subset. Both differ
+            result = 1;
+        } else if ((arr1[i] & arr2[i]) == arr2[i]) {
+            // arr2 is subset of arr2
+            if (result == 1)
+                return -1; // Previous result was subset. Both differ
+            result = 2;
+        }
+    }
+    return result;
+}
+
+void p_clusterBroadcastPatchVersionUsingPong() {
+    dictIterator *di;
+    dictEntry *de;
+
+    di = dictGetSafeIterator(server.cluster->nodes);
+    while((de = dictNext(di)) != NULL) {
+        clusterNode *node = dictGetVal(de);
+
+        if (!node->link) continue;
+        if (node == myself || nodeInHandshake(node)) continue;
+        /*if (target == CLUSTER_BROADCAST_LOCAL_SLAVES) {
+            int local_slave =
+                nodeIsSlave(node) && node->slaveof &&
+                (node->slaveof == myself || node->slaveof == myself->slaveof);
+            if (!local_slave) continue;
+        }*/
+        clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
+    }
+    dictReleaseIterator(di);
+}
+
+void p_clusterBroadcastPatch(int version) {
+    dictIterator *di;
+    dictEntry *de;
+
+    di = dictGetSafeIterator(server.cluster->nodes);
+    while((de = dictNext(di)) != NULL) {
+        clusterNode *node = dictGetVal(de);
+
+        if (!node->link) continue;
+        if (node == myself || nodeInHandshake(node)) continue;
+        p_clusterSendPatch(node, version);
+        // clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
+    }
+    dictReleaseIterator(di);
+}
+void p_setPatchVersion(int version, char* patch, int method, int from_client) {
+    if (version > MAX_PATCHES) {
+        fprintf(stderr, "Patch version too high! %d is the maximum!\n", MAX_PATCHES);
+        exit(1);
+    }
+
+    if (version > myself->max_patch_version) { 
+        myself->max_patch_version = version;
+    }
+    
+    // Version 1 = Index 0
+    int bit = (version - 1) % 8;
+    int row = (version - 1) / 8;
+    // Add patch to history only
+    if ((myself->available_patches[row] & (1UL << bit)) == 0) {
+        memcpy(myself->patches[version-1],patch,MAX_PATCH_NAME_LENGTH);
+        myself->patch_methods[version-1] = method;
+
+        myself->available_patches[row] |= (1UL << bit);
+        wf_log("[REDIS] [New Patch Registered] [%lf] [%.40s] [%d] [%d] [%d]\n", wf_time(), myself->name, version, method, from_client);
+    }
+   
+    myself->flags |= CLUSTER_NODE_CHECK_PATCH;
+    // I have a new patch. Broadcast it!
+    if (from_client && (method & PATCH_METHOD_EAGER))
+       p_clusterBroadcastPatch(version); 
+}
+
+void p_migrate(void) {
+    // No patch pending
+    if ((myself->flags & CLUSTER_NODE_PATCH_PENDING) == 0)
+        return;
+    
+    bool res = wf_quiescence();
+    // Patch pending, but quiescence is not ready yet. Try later agian..
+    if (!res)
+        return;
+
+    // Migration was successful!
+    uint8_t method = myself->patch_methods[myself->current_patch_version - 1];
+    myself->current_patch_version += 1;
+    // We always use the "real" version, so increment version first, than output (otherwise first version reports 0 etc.)
+    wf_log("[REDIS] [Patch Applied] [%lf] [%.40s] [%d] [%d]\n", wf_time(), myself->name, myself->current_patch_version, method);
+    
+    myself->flags &= ~CLUSTER_NODE_PATCH_PENDING; // Clear flag. Patch applied
+        
+    if ((method & PATCH_METHOD_EAGER) && (method & PATCH_METHOD_SYNC)) {
+        // We are eager and we have a new version. We immediately broadcast it!
+        p_clusterBroadcastPatchVersionUsingPong();
+    }
+    /* Scenario:
+     * Time | Action
+     * 1    | Node receives patch 1
+     * 2    | Node receives patch 2
+     * 3    | Node applies patch 1
+     * 4    | Nothing would happen, because both, patch 1 and 2, set the same flag to true,
+     *      | thus, the flag of patch 2 is "lost".
+     * Solution: We check again for a patch after mgiration.
+     */
+    myself->flags |= CLUSTER_NODE_CHECK_PATCH;
+}
+
+void p_applyPatchCheck(void) {
+    if (myself->flags & CLUSTER_NODE_CHECK_PATCH)
+        p_applyPatch();
+    if ((myself->flags & CLUSTER_NODE_CHECK_PATCH_SYNC) && (myself->flags & CLUSTER_NODE_PATCH_SYNC_WAITING)) {
+        // CLUSTER_NODE_CHECK_PATCH_SYNC is only set when some other node changes its version.
+        // So we only need to call p_applyPatch if the current patch also requires synchronisation.
+        p_applyPatch();
+    }
+}
+
+void p_applyPatch(void) {
+    // Reset flags. We check it now!
+    myself->flags &= ~CLUSTER_NODE_CHECK_PATCH;
+    myself->flags &= ~CLUSTER_NODE_CHECK_PATCH_SYNC;
+
+    uint16_t next_version = myself->current_patch_version + 1;
+
+    // Index access
+    int idx = next_version - 1;
+    int row = idx / 8;
+    int bit = idx % 8;
+    
+    // Patch does not exist, we may get it from some other node
+    // or user has not set this patch yet.
+    if ((myself->available_patches[row] & (1UL << bit)) == 0) return;
+
+    uint8_t method = myself->patch_methods[idx];
+    
+    /* #############################################
+     * #### SYNCHRONISATION (PATCH_METHOD_SYNC) ####
+     * #############################################
+     * */
+    if (method & PATCH_METHOD_SYNC) {
+        myself->flags |= CLUSTER_NODE_PATCH_SYNC_WAITING;
+        
+        uint16_t sync_min_version = 0;
+
+        // We iterate in a loop and every patch can require a different method.
+        // But we want to collect this information only once, so disable it.
+        dictIterator *di;
+        dictEntry *de;
+        
+        int first = 1;
+        di = dictGetSafeIterator(server.cluster->nodes);
+        while((de = dictNext(di)) != NULL) {
+            clusterNode *node = dictGetVal(de);
+            // if (!node->link) continue;
+            if (node == myself || nodeInHandshake(node)) continue;
+            if (first || node->current_patch_version < sync_min_version) sync_min_version = node->current_patch_version;
+            first = 0;
+        }
+        dictReleaseIterator(di);
+
+        // We allow at most 1 version difference between nodes
+        // (but if our node is far behind, keep patching!
+        if (next_version > sync_min_version + 1) return; // Do not apply this patch. We are too far ahead otherwise..
+    }
+    // Delete this flag as we apply a patch now!
+    myself->flags &= ~CLUSTER_NODE_PATCH_SYNC_WAITING;
+    
+    char *patch = myself->patches[idx];
+    wf_set_patch(patch);
+    wf_signal_patching();
+    wf_log("[REDIS] [Patch Signaled] [%lf] [%.40s] [%d] [%d]\n", wf_time(), myself->name, myself->current_patch_version + 1, method);
+    
+    // Patch is pending! We have to quiescence next.
+    myself->flags |= CLUSTER_NODE_PATCH_PENDING;
+}
+
+// Old function. Here, we immediately wait for the patch. But this has latency impact!
+void p_applyPatch2(void) {
+    // Reset flags. We check it now!
+    myself->flags &= ~CLUSTER_NODE_CHECK_PATCH;
+    myself->flags &= ~CLUSTER_NODE_CHECK_PATCH_SYNC;
+
+    int sync = 1; // Switch to disable iteration of nodes
+    uint16_t sync_min_version = 0;
+    int eager_sync_patched = 0;
+
+    for (uint16_t next_version = myself->current_patch_version + 1; next_version <= myself->max_patch_version; next_version++) {
+        // Index access
+        int idx = next_version - 1;
+        int row = idx / 8;
+        int bit = idx % 8;
+        
+        // Patch does not exist, we may get it from some other node
+        // or user has not set this patch yet.
+        if ((myself->available_patches[row] & (1UL << bit)) == 0) break;
+
+        uint8_t method = myself->patch_methods[idx];
+        
+        /* #############################################
+         * #### SYNCHRONISATION (PATCH_METHOD_SYNC) ####
+         * #############################################
+         * */
+        if (method & PATCH_METHOD_SYNC) {
+            myself->flags |= CLUSTER_NODE_PATCH_SYNC_WAITING;
+            // We iterate in a loop and every patch can require a different method.
+            // But we want to collect this information only once, so disable it.
+            if (sync) {
+                sync = 0; // Do not call this block again in this loop.
+
+                dictIterator *di;
+                dictEntry *de;
+                
+                int first = 1;
+                di = dictGetSafeIterator(server.cluster->nodes);
+                while((de = dictNext(di)) != NULL) {
+                    clusterNode *node = dictGetVal(de);
+                    // if (!node->link) continue;
+                    if (node == myself || nodeInHandshake(node)) continue;
+                    if (first || node->current_patch_version < sync_min_version) sync_min_version = node->current_patch_version;
+                    first = 0;
+                }
+                dictReleaseIterator(di);
+            }
+
+            // Use information from previous method
+            // We allow at most 1 version difference between nodes
+            // (but if our node is far behind, keep patching!
+           
+            if (next_version > sync_min_version + 1) break; // Do not apply this patch. We are too far ahead otherwise..
+        }
+        // Delete this flag as the new method will set it again.
+        myself->flags &= ~CLUSTER_NODE_PATCH_SYNC_WAITING;
+        
+        char *patch = myself->patches[idx];
+        wf_set_patch(patch);
+
+        wf_signal_patching_and_quiescence();
+        myself->current_patch_version = next_version;
+        wf_log("[REDIS] [Patch Applied] [%lf] [%.40s] [%d] [%d]\n", wf_time(), myself->name, myself->current_patch_version, method);
+        
+        if ((method & PATCH_METHOD_EAGER) && (method & PATCH_METHOD_SYNC))
+            eager_sync_patched = 1;
+    }
+    
+    // We are eager and we have a new version. We immediately broadcast it!
+    if (eager_sync_patched)
+        p_clusterBroadcastPatchVersionUsingPong();
+}
+
 /* Send an UPDATE message to the specified link carrying the specified 'node'
  * slots configuration. The node name, slots bitmap, and configEpoch info
  * are included. */
@@ -4018,7 +4465,7 @@ void clusterCron(void) {
     mstime_t handshake_timeout;
 
     iteration++; /* Number of times this function was called so far. */
-
+    
     clusterUpdateMyselfHostname();
 
     /* The handshake timeout is the time after which a handshake node that was
@@ -4212,6 +4659,10 @@ void clusterCron(void) {
 
     if (update_state || server.cluster->state == CLUSTER_FAIL)
         clusterUpdateState();
+    
+    // migrate before apply_patch, so we "ensure" that we migrate at the next iteration to not put too much load into one iteration.
+    p_migrate();
+    p_applyPatchCheck();
 }
 
 /* This function is called before the event handler returns to sleep for
@@ -4903,6 +5354,8 @@ const char *clusterGetMessageTypeString(int type) {
     case CLUSTERMSG_TYPE_UPDATE: return "update";
     case CLUSTERMSG_TYPE_MFSTART: return "mfstart";
     case CLUSTERMSG_TYPE_MODULE: return "module";
+    case CLUSTERMSG_TYPE_PATCH_REQUEST: return "patch-request";
+    case CLUSTERMSG_TYPE_PATCH: return "patches";
     }
     return "unknown";
 }
@@ -7099,3 +7552,4 @@ unsigned int countChannelsInSlot(unsigned int hashslot) {
     raxStop(&iter);
     return j;
 }
+
diff --git a/src/cluster.h b/src/cluster.h
index f198f0f6d..fd2b4b24e 100644
--- a/src/cluster.h
+++ b/src/cluster.h
@@ -5,10 +5,26 @@
  * Redis cluster data structures, defines, exported API.
  *----------------------------------------------------------------------------*/
 
+// Live patching constants
+#define PATCH_REQUEST_DELAY 5000 // unit is ms; 5s
+
+// Live patching methods
+// Set synchronisation
+#define PATCH_METHOD_NOSYNC (1UL << 0)
+#define PATCH_METHOD_SYNC (1UL << 1)
+
+// Set aggressiveness
+#define PATCH_METHOD_LAZY (1UL << 2)
+#define PATCH_METHOD_EAGER (1UL << 3)
+
+
 #define CLUSTER_SLOTS 16384
 #define CLUSTER_OK 0            /* Everything looks ok */
 #define CLUSTER_FAIL 1          /* The cluster can't work */
 #define CLUSTER_NAMELEN 40      /* sha1 hex length */
+#define MAX_PATCHES 16 /* Maximum number of patches. Multiple of 8 */
+#define MAX_PATCHES_ARR MAX_PATCHES/8          /* Maximum number of patches. Multiple of 8 */
+#define MAX_PATCH_NAME_LENGTH 250
 #define CLUSTER_PORT_INCR 10000 /* Cluster port = baseport + PORT_INCR */
 
 /* The following defines are amount of time, sometimes expressed as
@@ -54,6 +70,10 @@ typedef struct clusterLink {
 #define CLUSTER_NODE_MEET 128     /* Send a MEET message to this node */
 #define CLUSTER_NODE_MIGRATE_TO 256 /* Master eligible for replica migration. */
 #define CLUSTER_NODE_NOFAILOVER 512 /* Slave will not try to failover. */
+#define CLUSTER_NODE_CHECK_PATCH 1024 /* Check if we should patch. */
+#define CLUSTER_NODE_CHECK_PATCH_SYNC 2048 /* Check if we should patch if patch method is sync. */
+#define CLUSTER_NODE_PATCH_SYNC_WAITING 4096 /* Patch should be applied but we wait for other nodes to also reach their version */
+#define CLUSTER_NODE_PATCH_PENDING 8192 /* A patch is in progress. We have to quiescence! */
 #define CLUSTER_NODE_NULL_NAME "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
 
 #define nodeIsMaster(n) ((n)->flags & CLUSTER_NODE_MASTER)
@@ -97,7 +117,9 @@ typedef struct clusterLink {
 #define CLUSTERMSG_TYPE_MFSTART 8       /* Pause clients for manual failover */
 #define CLUSTERMSG_TYPE_MODULE 9        /* Module cluster API message. */
 #define CLUSTERMSG_TYPE_PUBLISHSHARD 10 /* Pub/Sub Publish shard propagation */
-#define CLUSTERMSG_TYPE_COUNT 11        /* Total number of message types. */
+#define CLUSTERMSG_TYPE_PATCH_REQUEST 11        /* Patch message. */
+#define CLUSTERMSG_TYPE_PATCH 12        /* Patch message. */
+#define CLUSTERMSG_TYPE_COUNT 13        /* Total number of message types. */
 
 /* Flags that a module can set in order to prevent certain Redis Cluster
  * features to be enabled. Useful when implementing a different distributed
@@ -145,6 +167,17 @@ typedef struct clusterNode {
     clusterLink *link;          /* TCP/IP link established toward this node */
     clusterLink *inbound_link;  /* TCP/IP link accepted from this node */
     list *fail_reports;         /* List of nodes signaling this as failing */
+
+    /* Live Patching */
+    uint16_t max_patch_version;
+    uint16_t current_patch_version;
+    // Patches
+    uint8_t available_patches[MAX_PATCHES_ARR];
+    char patches[MAX_PATCHES][MAX_PATCH_NAME_LENGTH];
+    uint8_t patch_methods[MAX_PATCHES];
+    // Patch Request
+    mstime_t patch_request_times[MAX_PATCHES];
+
 } clusterNode;
 
 /* Slot to keys for a single slot. The keys in the same slot are linked together
@@ -222,7 +255,7 @@ typedef struct {
     uint16_t cport;             /* cluster port last time it was seen */
     uint16_t flags;             /* node->flags copy */
     uint16_t pport;             /* plaintext-port, when base port is TLS */
-    uint16_t notused1;
+    uint16_t notused1;          /* Used for the current patch version */
 } clusterMsgDataGossip;
 
 typedef struct {
@@ -248,6 +281,17 @@ typedef struct {
     unsigned char bulk_data[3]; /* 3 bytes just as placeholder. */
 } clusterMsgModule;
 
+typedef struct {
+    uint8_t patches_to_request[MAX_PATCHES_ARR];
+} clusterMsgPatchRequest;
+
+typedef struct {
+    char patch[MAX_PATCH_NAME_LENGTH];
+    uint16_t version;
+    uint8_t method;
+} clusterMsgPatch;
+
+
 /* The cluster supports optional extension messages that can be sent
  * along with ping/pong/meet messages to give additional info in a 
  * consistent manner. */
@@ -301,6 +345,14 @@ union clusterMsgData {
     struct {
         clusterMsgModule msg;
     } module;
+
+    struct {
+        clusterMsgPatchRequest request;
+    } patchRequest;
+
+    struct {
+        clusterMsgPatch patch;
+    } patch;
 };
 
 #define CLUSTER_PROTO_VER 1 /* Cluster bus protocol version. */
@@ -329,6 +381,11 @@ typedef struct {
     uint16_t flags;      /* Sender node flags */
     unsigned char state; /* Cluster state from the POV of the sender */
     unsigned char mflags[3]; /* Message flags: CLUSTERMSG_FLAG[012]_... */
+
+    uint16_t current_patch_version;
+    uint8_t available_patches[MAX_PATCHES_ARR];
+
+
     union clusterMsgData data;
 } clusterMsg;
 
@@ -361,7 +418,10 @@ static_assert(offsetof(clusterMsg, cport) == 2248, "unexpected field offset");
 static_assert(offsetof(clusterMsg, flags) == 2250, "unexpected field offset");
 static_assert(offsetof(clusterMsg, state) == 2252, "unexpected field offset");
 static_assert(offsetof(clusterMsg, mflags) == 2253, "unexpected field offset");
-static_assert(offsetof(clusterMsg, data) == 2256, "unexpected field offset");
+static_assert(offsetof(clusterMsg, current_patch_version) == 2256, "unexpected field offset");
+static_assert(offsetof(clusterMsg, available_patches) == 2258, "unexpected field offset");
+// This gets filled to the next 8 bytes, so 2264.
+//static_assert(offsetof(clusterMsg, data) == 2262+MAX_PATCHES_ARR, "unexpected field offset");
 
 #define CLUSTERMSG_MIN_LEN (sizeof(clusterMsg)-sizeof(union clusterMsgData))
 
@@ -400,5 +460,6 @@ void slotToChannelDel(sds channel);
 void clusterUpdateMyselfHostname(void);
 void clusterUpdateMyselfAnnouncedPorts(void);
 void freeClusterLink(clusterLink *link);
+int p_patchMethodRequiresSync(int method);
 
 #endif /* __CLUSTER_H */
diff --git a/src/commands.c b/src/commands.c
index ea8493e9c..2ee703253 100644
--- a/src/commands.c
+++ b/src/commands.c
@@ -1069,6 +1069,37 @@ struct redisCommandArg HELLO_Args[] = {
 {0}
 };
 
+/********** PATCH ********************/
+
+/* PATCH history */
+#define PATCH_History NULL
+
+/* PATCH tips */
+#define PATCH_tips NULL
+
+/* PATCH argument table */
+struct redisCommandArg PATCH_Args[] = {
+{"method",ARG_TYPE_STRING,-1,NULL,NULL,NULL,CMD_ARG_NONE},
+{"version",ARG_TYPE_INTEGER,-1,NULL,NULL,NULL,CMD_ARG_NONE},
+{"patch",ARG_TYPE_STRING,-1,NULL,NULL,NULL,CMD_ARG_NONE},
+{0}
+};
+
+/********** PATCH_GET ********************/
+
+/* PATCH_GET history */
+#define PATCH_GET_History NULL
+
+/* PATCH_GET tips */
+#define PATCH_GET_tips NULL
+
+/* PATCH_GET argument table */
+struct redisCommandArg PATCH_GET_Args[] = {
+{"number",ARG_TYPE_INTEGER,-1,NULL,NULL,NULL,CMD_ARG_NONE},
+{"delay",ARG_TYPE_INTEGER,-1,NULL,NULL,NULL,CMD_ARG_NONE},
+{0}
+};
+
 /********** PING ********************/
 
 /* PING history */
@@ -7159,6 +7190,8 @@ struct redisCommand redisCommandTable[] = {
 {"client","A container for client connection commands","Depends on subcommand.","2.4.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,CLIENT_History,CLIENT_tips,NULL,-2,CMD_SENTINEL,0,.subcommands=CLIENT_Subcommands},
 {"echo","Echo the given string","O(1)","1.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,ECHO_History,ECHO_tips,echoCommand,2,CMD_LOADING|CMD_STALE|CMD_FAST,ACL_CATEGORY_CONNECTION,.args=ECHO_Args},
 {"hello","Handshake with Redis","O(1)","6.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,HELLO_History,HELLO_tips,helloCommand,-1,CMD_NOSCRIPT|CMD_LOADING|CMD_STALE|CMD_FAST|CMD_NO_AUTH|CMD_SENTINEL|CMD_ALLOW_BUSY,ACL_CATEGORY_CONNECTION,.args=HELLO_Args},
+{"patch","Trigger patching.","O(1)","1.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,PATCH_History,PATCH_tips,patchCommand,4,CMD_MAY_REPLICATE,0,.args=PATCH_Args},
+{"patch_get","Get the value of a key","O(1)","1.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,PATCH_GET_History,PATCH_GET_tips,patchGetCommand,3,0,0,.args=PATCH_GET_Args},
 {"ping","Ping the server","O(1)","1.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,PING_History,PING_tips,pingCommand,-1,CMD_FAST|CMD_SENTINEL,ACL_CATEGORY_CONNECTION,.args=PING_Args},
 {"quit","Close the connection","O(1)","1.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,QUIT_History,QUIT_tips,quitCommand,-1,CMD_ALLOW_BUSY|CMD_NOSCRIPT|CMD_LOADING|CMD_STALE|CMD_FAST|CMD_NO_AUTH,ACL_CATEGORY_CONNECTION},
 {"reset","Reset the connection","O(1)","6.2.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CONNECTION,RESET_History,RESET_tips,resetCommand,1,CMD_NOSCRIPT|CMD_LOADING|CMD_STALE|CMD_FAST|CMD_NO_AUTH|CMD_ALLOW_BUSY,ACL_CATEGORY_CONNECTION},
diff --git a/src/commands/patch.json b/src/commands/patch.json
new file mode 100644
index 000000000..63587d670
--- /dev/null
+++ b/src/commands/patch.json
@@ -0,0 +1,26 @@
+{
+    "PATCH": {
+        "summary": "Trigger patching.", "complexity": "O(1)",
+        "group": "connection",
+        "since": "1.0.0",
+        "arity": 4,
+        "function": "patchCommand",
+        "command_flags": [
+            "MAY_REPLICATE"
+        ],
+        "arguments": [
+            {
+                "name": "method",
+                "type": "string"
+            },
+            {
+                "name": "version",
+                "type": "integer"
+            },
+            {
+                "name": "patch",
+                "type": "string"
+            }
+        ]
+    }
+}
diff --git a/src/commands/patch_get.json b/src/commands/patch_get.json
new file mode 100644
index 000000000..aeccd85a7
--- /dev/null
+++ b/src/commands/patch_get.json
@@ -0,0 +1,20 @@
+{
+    "PATCH_GET": {
+        "summary": "Get the value of a key",
+        "complexity": "O(1)",
+        "group": "connection",
+        "since": "1.0.0",
+        "arity": 3,
+        "function": "patchGetCommand",
+        "arguments": [
+            {
+                "name": "number",
+                "type": "integer"
+            },
+            {
+                "name": "delay",
+                "type": "integer"
+            }
+        ]
+    }
+}
diff --git a/src/networking.c b/src/networking.c
index 90cc64d70..2752fcb54 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -2467,6 +2467,7 @@ void commandProcessed(client *c) {
  * The function returns C_ERR in case the client was freed as a side effect
  * of processing the command, otherwise C_OK is returned. */
 int processCommandAndResetClient(client *c) {
+
     int deadclient = 0;
     client *old_client = server.current_client;
     server.current_client = c;
diff --git a/src/patch.c b/src/patch.c
new file mode 100644
index 000000000..771a2bb0f
--- /dev/null
+++ b/src/patch.c
@@ -0,0 +1,5 @@
+#include "server.h"
+
+void patchGetCommandResult(client *c, long long number) {
+    addReplyBulkLongLong(c, number + 0);
+}
diff --git a/src/server.c b/src/server.c
index e1d1b316e..3df95bfe9 100644
--- a/src/server.c
+++ b/src/server.c
@@ -37,6 +37,7 @@
 #include "mt19937-64.h"
 #include "functions.h"
 #include "syscheck.h"
+#include "wf-userland.h"
 
 #include <time.h>
 #include <signal.h>
@@ -4378,6 +4379,59 @@ void pingCommand(client *c) {
     }
 }
 
+
+void patchGetCommand(client *c) {
+    long long number;
+    getLongLongFromObject(c->argv[1], &number);
+
+    long long delay;
+    getLongLongFromObject(c->argv[2], &delay);
+
+    msleep(delay);
+    
+    patchGetCommandResult(c, number);
+}
+
+void patchCommand(client *c) {
+    int patch_method = 0;
+    char *method = c->argv[1]->ptr;
+    //if (strcasecmp(method, "master-replica-propagate") == 0) {
+    //    forceCommandPropagation(c, PROPAGATE_REPL);
+    //    patch_method = 0;
+    //}
+    if (strcasecmp(method, "master-replicas") == 0) {
+    } else if (strcasecmp(method, "lazy") == 0) {
+        patch_method |= PATCH_METHOD_LAZY;
+        patch_method |= PATCH_METHOD_NOSYNC;
+    } else if (strcasecmp(method, "lazy-sync") == 0) {
+        patch_method |= PATCH_METHOD_LAZY;
+        patch_method |= PATCH_METHOD_SYNC;
+    } else if (strcasecmp(method, "eager") == 0 ) {
+        patch_method |= PATCH_METHOD_EAGER;
+        patch_method |= PATCH_METHOD_NOSYNC;
+    } else if (strcasecmp(method, "eager-sync") == 0 ) {
+        patch_method |= PATCH_METHOD_EAGER;
+        patch_method |= PATCH_METHOD_SYNC;
+    }
+
+    //fprintf(stderr, "Hi: %d\n", getClientType(c));
+    //sleep(3);
+    //block_client(c);
+
+    long long version;
+    getLongLongFromObject(c->argv[2], &version);
+
+    char *patch = c->argv[3]->ptr;
+
+    // Set for cluster
+    p_setPatchVersion(version, patch, patch_method, 1);
+
+    //clusterSendPatch();
+    //replicasSendPatch();
+
+    addReplyBulkCString(c, "Live Patching triggered.");
+}
+
 void echoCommand(client *c) {
     addReplyBulk(c,c->argv[1]);
 }
@@ -6851,6 +6905,18 @@ redisTestProc *getTestProcByName(const char *name) {
 #endif
 
 int main(int argc, char **argv) {
+	struct wf_configuration wf_config = {
+        .amount_priorities = 4,
+        .trigger_sleep_ms = -1,
+        .trigger_global_quiescence = NULL,
+        .trigger_local_quiescence = NULL,
+        .patch_applied = NULL,
+        .patch_done = NULL,
+    };
+    wf_init(wf_config);
+    wf_set_patch_method(1);
+    wf_thread_birth("main");
+
     struct timeval tv;
     int j;
     char config_from_stdin = 0;
diff --git a/src/server.h b/src/server.h
index 82e4db938..6cf7c28c2 100644
--- a/src/server.h
+++ b/src/server.h
@@ -3541,6 +3541,8 @@ void lcsCommand(client *c);
 void quitCommand(client *c);
 void resetCommand(client *c);
 void failoverCommand(client *c);
+void patchGetCommand(client *c);
+void patchCommand(client *c);
 
 #if defined(__GNUC__)
 void *calloc(size_t count, size_t size) __attribute__ ((deprecated));
diff --git a/src/wf-userland.h b/src/wf-userland.h
new file mode 120000
index 000000000..84f68540a
--- /dev/null
+++ b/src/wf-userland.h
@@ -0,0 +1 @@
+wfpatch-userland/wf-userland.h
\ No newline at end of file
diff --git a/src/wfpatch-userland/wf-userland.c b/src/wfpatch-userland/wf-userland.c
new file mode 100644
index 000000000..47d0776da
--- /dev/null
+++ b/src/wfpatch-userland/wf-userland.c
@@ -0,0 +1,1893 @@
+#define _GNU_SOURCE 1
+#include <stdbool.h>
+#include <stdio.h>
+#include <glob.h>
+#include <stdarg.h>
+#include <sys/epoll.h>
+#include <pthread.h>
+#include <dlfcn.h>
+#include <stddef.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <assert.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <string.h>
+#include <link.h>
+#include <elf.h>
+
+//////////////////// COUNT VMA ////////////////////////
+#include <regex.h>      
+static void count_vmas(char *);
+///////////////////////////////////////////////////////
+//
+#include "wf-userland.h"
+
+static void *wf_plt_trampoline(char *name, void *func_ptr);
+
+
+static struct wf_configuration wf_config;
+
+#define log(...) do { fprintf(stderr, "wf-userland: "__VA_ARGS__); } while(0)
+#define die(...) do { log("[ERROR] " __VA_ARGS__); exit(EXIT_FAILURE); } while(0)
+#define die_perror(m, ...) do { perror(m); die(__VA_ARGS__); } while(0)
+
+// WF_LOGFILE
+static FILE *wf_log_file;
+void wf_log(char *fmt, ...) {
+    if (wf_log_file) {
+        va_list(args);
+        va_start(args, fmt);
+        vfprintf(wf_log_file, fmt, args);
+        fflush(wf_log_file);
+    }
+}
+
+// Returns the a timestamp in miliseconds. The first call zeroes the clock
+static struct timespec wf_ts0;
+static void wf_timestamp_reset(void) { // returns 0 seconds first time called
+    clock_gettime(CLOCK_REALTIME, &wf_ts0);
+}
+
+static double wf_timestamp(void) { // returns 0 seconds first time called
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    return (ts.tv_sec - wf_ts0.tv_sec)*1000. + (ts.tv_nsec - wf_ts0.tv_nsec) / 1000000.;
+}
+
+double wf_time(void) {
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    return ts.tv_sec*1000. + ts.tv_nsec / 1000000.;
+}
+
+
+
+////////////////////////////////////////////////////////////////
+// Kernel Interface
+static unsigned pagesize;
+static void *addr_to_page(void *addr) {
+    if (pagesize == 0) {
+        pagesize = sysconf(_SC_PAGESIZE);
+    }
+    void *page = addr - ((uintptr_t) addr % pagesize);
+    return page;
+}
+
+int wf_kernel_pin(void* start, void* end) {
+    // Pin code as non shared for AS generations
+    uintptr_t start_page = (uintptr_t)addr_to_page(start);
+    uintptr_t end_page   = (uintptr_t)addr_to_page(end + pagesize - 1);
+
+    int rc = syscall(1000, 4, start_page, end_page - start_page);
+    log("memory pin [%p:+0x%lx]: rc=%d\n", (void*)start_page,
+        end_page - start_page, rc);
+    if (rc == -1)
+        die_perror("wf_kernel_pin", "Could not unshare the text segment");
+    
+    return rc;
+}
+
+int wf_kernel_as_new(void) {
+    int rc = syscall(1000, 0);
+    // log("AS create: %d\n", rc);
+    if (rc == -1)
+        die_perror("wf_kernel_as_new", "Could not create a new address space");
+    return rc;
+}
+
+int wf_kernel_as_switch(int as_id) {
+    int rc = syscall(1000, 3, as_id);
+    // log("AS switch: %d %d\n", as_id, rc);
+    if (rc == -1)
+        die_perror("wf_kernel_as_switch", "Could not migrate to the new address space");
+    return rc;
+}
+
+int wf_kernel_as_delete(int as_id) {
+    int rc = syscall(1000, 1, as_id);
+    // log("address space delete(%d)=%d\n", as_id, rc);
+    return rc;
+}
+
+
+////////////////////////////////////////////////////////////////
+// Apply Patch
+// Magic Names: ehdr, shstr
+#define offset_to_ptr(offset) (((void*) (ehdr)) + ((int) (offset)))
+#define shdr_from_idx(idx) offset_to_ptr(ehdr->e_shoff + ehdr->e_shentsize * idx);
+#define section_name(shdr) (((char*) offset_to_ptr(shstr->sh_offset)) + shdr->sh_name)
+
+extern void *_GLOBAL_OFFSET_TABLE_;
+
+bool wf_relocate_calc(unsigned type,
+                        /* input */  uintptr_t reloc_src, uintptr_t reloc_dst, uintptr_t reloc_addend,
+                        /* output */ void **loc, uint64_t *val, char *size) {
+
+    uintptr_t S = reloc_src, A = reloc_addend, P = reloc_dst;
+
+#define is_pc32_rel(x) ((INT_MIN <= (intptr_t) (x)) && ((intptr_t) (x) <= INT_MAX))
+
+    *loc = (void*) reloc_dst;
+    switch (type) {
+    case R_X86_64_NONE:
+        return false;
+    case R_X86_64_PC32:
+    case R_X86_64_PLT32:
+    case R_X86_64_GOTPCREL:
+    case R_X86_64_REX_GOTPCRELX:
+        *val = (uint64_t)(S + A - P);
+        assert(is_pc32_rel(*val) && "Patch was loaded tooo far away");
+        *size = 4;
+        break;
+    case R_X86_64_32S:
+        *val = (uint64_t)((int32_t)S + A);
+        *size = 4;
+        break;
+    case R_X86_64_32:
+        *val = (uint64_t)((uint32_t)S + A);
+        *size = 4;
+        break;
+    case R_X86_64_64:
+        *val = (uint64_t) S + A;
+        *size = 8;
+        break;
+    default:
+        die("Unsupported relocation %d for source (0x%lx <- 0x%lx)\n",
+            type, reloc_dst, reloc_src);
+    }
+    return true;
+}
+
+void *wf_find_symbol(char * name);
+
+void wf_relocate(Elf64_Ehdr *ehdr, void *elf_end, Elf64_Shdr* shdr) {
+    // Section Header String table
+    Elf64_Shdr *shstr = shdr_from_idx(ehdr->e_shstrndx);
+    
+    Elf64_Shdr *shdr_symtab = shdr_from_idx(shdr->sh_link);
+    Elf64_Sym *symbol_table = offset_to_ptr(shdr_symtab->sh_offset);
+    
+    Elf64_Shdr *shdr_strtab = shdr_from_idx(shdr_symtab->sh_link);
+    char *strtab = offset_to_ptr(shdr_strtab->sh_offset);
+
+    // Which section should be modified
+    Elf64_Shdr * shdr_target = shdr_from_idx(shdr->sh_info);
+
+    unsigned  rela_num = shdr->sh_size / shdr->sh_entsize;
+    log("[%s] %d relocs for %s\n",
+           section_name(shdr),
+           rela_num,
+           section_name(shdr_target));
+
+    if (!strncmp(".rela.debug_", section_name(shdr), 12)) {
+        log(".. debug relocations, skipping.\n");
+        return;
+    }
+
+    Elf64_Rela * rela = offset_to_ptr(shdr->sh_offset);
+    for (unsigned i = 0; i < rela_num; i++) {
+        Elf64_Rela * rela = offset_to_ptr(shdr->sh_offset + i * shdr->sh_entsize);
+
+        // Where to modify
+        uintptr_t reloc_dst = (uintptr_t)  offset_to_ptr(shdr_target->sh_offset + rela->r_offset);
+
+        // What should be written into that place
+        Elf64_Sym * symbol = &symbol_table[ELF64_R_SYM(rela->r_info)];
+        char *symbol_name = strtab + symbol->st_name;
+        void *reloc_src;
+        if (symbol->st_shndx != 0) {
+            Elf64_Shdr * symbol_section = shdr_from_idx(symbol->st_shndx);
+            if (ELF64_ST_TYPE(symbol->st_info) == STT_SECTION) {
+                symbol_name = section_name(symbol_section);
+                reloc_src = offset_to_ptr(symbol_section->sh_offset);
+            } else {
+                reloc_src = offset_to_ptr(symbol_section->sh_offset + symbol->st_value);
+            }
+        } else if (symbol_name && *symbol_name == 0) {
+            log("Empty Symbol name... continue on this...\n");
+            continue;
+        } else { 
+            // Find Name in original binary
+            reloc_src = wf_find_symbol(symbol_name);
+            if (!reloc_src) {
+                reloc_src = dlsym(RTLD_DEFAULT, symbol_name);
+                reloc_src = wf_plt_trampoline(symbol_name, reloc_src);
+            }
+            if (!reloc_src) {
+                log("Probaly `%s' is a library function that was not called in original binary. We do not support this yet.\n", symbol_name);
+                die("Could not find symbol %s.\n", symbol_name);
+            }
+        }
+
+        // FIXME: log_debug
+        // log("   %p+(%ld) -> %p (%s)\n", (void*)reloc_dst, rela->r_addend, reloc_src, symbol_name);
+
+        void* loc;
+        uint64_t val;
+        char size;
+        bool action = wf_relocate_calc(ELF64_R_TYPE(rela->r_info),
+                                       (uintptr_t) reloc_src, reloc_dst, rela->r_addend,
+                                       &loc, &val, &size);
+        if (!action) continue;
+
+        if (loc < (void*) ehdr || loc >= elf_end) {
+			die("bad relocation 0x%p for symbol %s\n", loc, symbol_name);
+		}
+
+        // log("   *%p = 0x%lx [%d]\n", loc, val, size);
+
+        if (size == 4) {
+            *(uint32_t *) loc = val;
+        } else if (size == 8) {
+            *(uint64_t *) loc = val;
+        } else
+            die("Invalid relocation size");
+
+    }
+}
+
+struct kpatch_patch_func {
+	unsigned long new_addr;
+	unsigned long new_size;
+	unsigned long old_addr;
+	unsigned long old_size;
+	unsigned long sympos;
+	char *name;
+	char *objname;
+};
+
+struct kpatch_relocation {
+	unsigned long dest;
+	unsigned int type;
+	int external;
+	long addend;
+	char *objname; /* object to which this rela applies to */
+	struct kpatch_symbol *ksym;
+};
+
+struct kpatch_symbol {
+	unsigned long src;
+	unsigned long sympos;
+	unsigned char bind, type;
+	char *name;
+	char *objname; /* object to which this sym belongs */
+};
+
+struct kpatch_patch_dynrela {
+	unsigned long dest;
+	unsigned long src;
+	unsigned long type;
+	unsigned long sympos;
+	char *name;
+	char *objname;
+	int external;
+	long addend;
+};
+
+struct kpatch_pre_patch_callback {
+	int (*callback)(void *obj);
+	char *objname;
+};
+struct kpatch_post_patch_callback {
+	void (*callback)(void *obj);
+	char *objname;
+};
+struct kpatch_pre_unpatch_callback {
+	void (*callback)(void *obj);
+	char *objname;
+};
+struct kpatch_post_unpatch_callback {
+	void (*callback)(void *obj);
+	char *objname;
+};
+
+static void *wf_vspace_end = NULL;
+static void *wf_vspace_bump_ptr = NULL;
+
+void * wf_vspace_reservere(uintptr_t bytes) {
+    uintptr_t size = ((bytes + 0xfff) & (~((uintptr_t) 0xfff)));
+    wf_vspace_bump_ptr -= size;
+    log("vspace %p (%lx %lx)\n", wf_vspace_bump_ptr, bytes, size);
+    return wf_vspace_bump_ptr;
+}
+
+static Elf64_Ehdr * wf_load_elf(char *filename_raw, bool close_to_binary, void **elf_end) {
+    char filename[PATH_MAX];
+    if(!realpath(filename_raw, filename)) die_perror("realpath", "file: %s | error: %s\n", filename_raw, strerror(errno));
+
+    int fd = open(filename, O_RDONLY);
+    if (!fd) die_perror("open", "Could not open patch file: %s", filename);
+
+    // Map the whole file
+    struct stat size;
+    if (fstat(fd, &size) == -1) die_perror("fstat", "Could not determine size: %s\n", filename);
+
+    void *hint = 0;
+    if (close_to_binary) {
+        hint = wf_vspace_reservere(size.st_size);
+    }
+    void *elf_start = mmap(hint, size.st_size, PROT_WRITE, MAP_PRIVATE, fd, 0);
+    if (elf_start == MAP_FAILED) die_perror("mmap", "Could not map patch: %s", filename);
+    *elf_end = elf_start + size.st_size;
+
+    // 1. Find Tables
+    Elf64_Ehdr *ehdr = elf_start;
+
+	if (strncmp((const char *)ehdr->e_ident, "\177ELF", 4) != 0) {
+		die("Patch is not an ELF file");
+	}
+    if (ehdr->e_ident[EI_CLASS] != ELFCLASS64) {
+        die("Patch is not an 64-Bit ELF");
+    }
+    return ehdr;
+}
+
+static void wf_unload_elf(Elf64_Ehdr *ehdr, void *elf_end) {
+    munmap(ehdr, (uintptr_t) elf_end - (uintptr_t) ehdr);
+}
+
+
+struct wf_symbol {
+    char * name;
+    void * addr;
+};
+
+static struct wf_symbol *wf_symbols = NULL;
+static unsigned wf_symbol_count;
+
+
+static int dl_iterate_cb_stop;
+static int
+dl_iterate_cb(struct dl_phdr_info *info, size_t size, void *data) {
+    Elf64_Ehdr *ehdr = (Elf64_Ehdr *) data;
+    // We only process the main binary
+    if (dl_iterate_cb_stop) return 0;
+    dl_iterate_cb_stop = 1;
+
+    // Section Header String table
+    Elf64_Shdr *shstr = shdr_from_idx(ehdr->e_shstrndx);
+
+    // Allocate enough space for all symbols
+    unsigned symbols_max = 0;
+    for (unsigned i = 0; i < ehdr->e_shnum; i++) {
+        Elf64_Shdr * shdr = shdr_from_idx(i);
+        if (shdr->sh_type == SHT_SYMTAB) {
+            Elf64_Sym *symbol_table = offset_to_ptr(shdr->sh_offset);
+            unsigned  symbol_count = shdr->sh_size / shdr->sh_entsize;
+            symbols_max += symbol_count;
+        }
+    }
+    wf_symbols = malloc(sizeof(struct wf_symbol) * symbols_max);
+    if (!wf_symbols) die_perror("malloc", "could not allocate space for symbols");
+
+    // Pin all the executable sections
+    for (int j = 0; j < info->dlpi_phnum; j++) {
+        const Elf64_Phdr *phdr = &info->dlpi_phdr[j];
+        if (phdr->p_type != PT_LOAD) continue;
+        void *seg_vstart = (void *) (info->dlpi_addr + phdr->p_vaddr);
+        void *seg_vend = seg_vstart + phdr->p_memsz;
+
+        if (phdr->p_flags & PF_X) { // Executable segment
+            wf_kernel_pin(seg_vstart, seg_vend);
+        }
+    }
+
+    // Initialize our patch bumping allocator before the actual
+    // binary. We need this space to allocate PLT entries
+    wf_vspace_end = (void*) ((uintptr_t) info->dlpi_addr & ~((uintptr_t) 0x1ff)) - 0x1000*1024;
+    assert(((uintptr_t)wf_vspace_end & 0x1ff) == 0 && "Not page alinged");
+    wf_vspace_bump_ptr = wf_vspace_end;
+
+    // Find all Symbols in ELF
+    for (unsigned i = 0; i < ehdr->e_shnum; i++) {
+        Elf64_Shdr * shdr = shdr_from_idx(i);
+        if (shdr->sh_type == SHT_SYMTAB) {
+            Elf64_Sym *symbol_table = offset_to_ptr(shdr->sh_offset);
+            unsigned  symbol_count = shdr->sh_size / shdr->sh_entsize;
+
+            Elf64_Shdr *shdr_strtab = shdr_from_idx(shdr->sh_link);
+            char *strtab = offset_to_ptr(shdr_strtab->sh_offset);
+
+            for (unsigned s = 0; s < symbol_count; s++) {
+                int sym_type = ELF32_ST_TYPE(symbol_table[s].st_info);
+                if (sym_type != STT_FUNC && sym_type != STT_OBJECT)
+                    continue;
+
+                char *sym_name = strtab + symbol_table[s].st_name;
+                ptrdiff_t sym_value = symbol_table[s].st_value;
+                void *sym_addr = (void*)info->dlpi_addr + sym_value;
+
+                wf_symbols[wf_symbol_count].name = strdup(sym_name);
+                wf_symbols[wf_symbol_count].addr = sym_addr;
+                wf_symbol_count += 1;
+                // log("found %s @ %p (+0x%lx)\n", sym_name, sym_addr, sym_value);
+            }
+        }
+    }
+    return 0;
+}
+
+
+void wf_load_symbols(char *filename) {
+    void * elf_end;
+    Elf64_Ehdr * ehdr = wf_load_elf(filename, /* I don't care where */ 0, &elf_end);
+
+    dl_iterate_cb_stop = false;
+    dl_iterate_phdr(dl_iterate_cb, ehdr);
+
+    wf_unload_elf(ehdr, elf_end);
+}
+
+void *wf_find_symbol(char * name) {
+    for (unsigned i = 0; i < wf_symbol_count; i++) {
+        if (strcmp(name, wf_symbols[i].name) == 0) {
+            return wf_symbols[i].addr;
+        }
+    }
+    
+    return 0;
+}
+
+static int wf_malloc_space = 0;
+static void *wf_malloc_ptr = 0;
+
+void *wf_malloc_near(unsigned char size) {
+    if (wf_malloc_space < size) {
+        wf_malloc_ptr = wf_vspace_reservere(4096);
+        {
+            void *x = mmap(wf_malloc_ptr, 4096,
+                           PROT_READ | PROT_WRITE | PROT_EXEC,
+                           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+            if (x != wf_malloc_ptr) die_perror("mmap", "wf_malloc_near\n");
+        }
+        wf_malloc_space = 4096;
+    }
+
+    void * ret = wf_malloc_ptr;
+    wf_malloc_ptr   += size;
+    wf_malloc_space -= size;
+    return ret;
+}
+
+static void *wf_plt_trampoline(char *name, void *func_ptr) {
+    struct plt_entry {
+        void *target;
+        char jmpq[6];
+    };
+    struct plt_entry *plt = wf_malloc_near(sizeof(struct plt_entry));
+
+    // jmp *%rip(-6)
+    plt->target = func_ptr;
+    plt->jmpq[0] = 0xff;
+    plt->jmpq[1] = 0x25;
+    *((uint32_t *)&plt->jmpq[2]) = -6 - 8;
+    log("    PLT %s == %p (%p)\n", name, func_ptr, &plt->jmpq);
+
+    return &plt->jmpq;
+}
+
+void wf_load_patch_from_file(char *filename) {
+    void * elf_end;
+    Elf64_Ehdr * ehdr = wf_load_elf(filename, /* close */ 1, &elf_end);
+
+    int rc = mprotect(ehdr, elf_end - (void*)ehdr, PROT_WRITE | PROT_EXEC | PROT_READ);
+    if (rc == -1) die_perror("mprotect", "Could not mprotect patch");
+
+
+    Elf64_Shdr *shstr = shdr_from_idx(ehdr->e_shstrndx);
+
+    // Extract all related sections from patch file
+    Elf64_Shdr *kpatch_strings = NULL, *kpatch_funcs = NULL, *kpatch_relocations = NULL, *kpatch_symbols=NULL;
+
+    for (unsigned i = 0; i < ehdr->e_shnum; i++) {
+        Elf64_Shdr * shdr = shdr_from_idx(i);
+
+        // Name of section
+        char *name = section_name(shdr);
+
+        // Perform relocations
+        if (shdr->sh_type == SHT_RELA) {
+            wf_relocate(ehdr, elf_end, shdr);
+        }
+
+        if (strcmp(name, ".kpatch.strings") == 0)
+            kpatch_strings = shdr;
+        else if (strcmp(name, ".kpatch.funcs") == 0)
+            kpatch_funcs = shdr;
+        else if (strcmp(name, ".kpatch.relocations") == 0)
+            kpatch_relocations = shdr;
+        else if (strcmp(name, ".kpatch.symbols") == 0)
+            kpatch_symbols = shdr;
+    }
+
+    // Iterate over all symbols
+    // printf("%d sections\n", ehdr->e_shnum);
+
+    // Extract arrays
+    struct kpatch_patch_func *funcs = offset_to_ptr(kpatch_funcs->sh_offset);
+    int funcs_count = kpatch_funcs->sh_size / sizeof(struct kpatch_patch_func);
+    assert(funcs_count * sizeof(struct kpatch_patch_func) == kpatch_funcs->sh_size);
+
+    struct kpatch_symbol *symbols = offset_to_ptr(kpatch_symbols->sh_offset);
+    int symbols_count = kpatch_symbols->sh_size / sizeof(struct kpatch_symbol);
+    assert(symbols_count * sizeof(struct kpatch_symbol) == kpatch_symbols->sh_size);
+
+    struct kpatch_relocation *relocations = offset_to_ptr(kpatch_relocations->sh_offset);
+    int relocations_count = kpatch_relocations->sh_size / sizeof(struct kpatch_relocation);
+    assert(relocations_count * sizeof(struct kpatch_relocation) == kpatch_relocations->sh_size);
+
+    for (unsigned f = 0; f < funcs_count; f++) {
+        log ("kpatch_func: name:%s objname:%s new: %p\n",
+             funcs[f].name, funcs[f].objname, (void*) funcs[f].new_addr);
+
+        funcs[f].old_addr = (uintptr_t) wf_find_symbol(funcs[f].name);
+        // printf("PATCH %p -> %p\n", funcs[f].old_addr, funcs[f].new_addr);
+        // Insert a call to the new function
+        char * jumpsite = (char *)funcs[f].old_addr;
+        void* page = addr_to_page(jumpsite);
+        int rc = mprotect(page, pagesize, PROT_WRITE | PROT_EXEC | PROT_READ);
+        
+        if (rc == -1)
+            die_perror("mprotect", "Cannot patch callsite at %p\n", page);
+        
+        *jumpsite = 0xe9; // jmp == 0xe9 OF OF OF OF
+        *(int32_t*)(jumpsite + 1) = funcs[f].new_addr - 5 -funcs[f].old_addr;
+        mprotect(page, pagesize, PROT_EXEC |PROT_READ);
+    }
+
+    // We know that ksyms are duplicated.
+    // for (unsigned k = 0; k < symbols_count; k++) {
+    //     printf("ksym: %s\n", symbols[k].name);
+    // }
+
+    // Relocations
+    for (unsigned r = 0; r < relocations_count; r++) {
+        struct kpatch_relocation *rela = &relocations[r];
+        struct kpatch_symbol *ksym = rela->ksym;
+
+        log("  reloc: [%s/%s pos=%ld, type=%d], ext=%d, type=%d, add=%d *%p\n",
+            ksym->objname, ksym->name, ksym->sympos, ksym->type,
+            rela->external, rela->type, rela->addend, (void*)rela->dest);
+
+        uintptr_t reloc_src;
+        if (rela->external) {
+            reloc_src = dlsym(RTLD_DEFAULT, ksym->name);
+            if (!reloc_src)
+                die("Library symbol %s not found", ksym->name);
+        } else {
+            reloc_src = wf_find_symbol(ksym->name);
+            log("    local %s == %p\n", ksym->name, reloc_src);
+            if (!reloc_src) {
+                die("Could not find symbol %s in original binary\n",
+                    ksym->name);
+            }
+        }
+
+        if (rela->type == R_X86_64_PLT32) {
+            if (ksym->sympos == 0) {
+                // Allocate space for trampolines
+                ksym->sympos = (uintptr_t)wf_plt_trampoline(ksym->name, reloc_src);
+            }
+            reloc_src = ksym->sympos;
+        } else if (rela->type == R_X86_64_GOTPCREL || rela->type == R_X86_64_REX_GOTPCRELX) {
+            if (ksym->sympos == 0) {
+                struct got_entry {
+                    void *target;
+                };
+                struct got_entry *got = wf_malloc_near(sizeof(struct got_entry));
+                ksym->sympos = (uintptr_t)got;
+                got->target = reloc_src;
+                log("    GOT %s == %p (%p)\n", ksym->name, reloc_src, got);
+            }
+            reloc_src = ksym->sympos;
+        } else if (rela->type == R_X86_64_PC32
+                   || rela->type == R_X86_64_64) {
+            log("    direct %s == %p\n", ksym->name, reloc_src);
+        } else {
+            die("Unsupported relocation type %d for library name %s\n",
+                rela->type, ksym->name);
+        }
+
+        void* loc;
+        uint64_t val;
+        char size;
+
+        bool action = wf_relocate_calc(
+            rela->type,
+            (uintptr_t) reloc_src, rela->dest, rela->addend,
+            &loc, &val, &size
+            );
+        if (!action) continue;
+        // printf("%p %p %d\n", ksym_addr, rela->dest, rela->addend);
+        // printf("PATCH *%p[%d] = %d\n", loc, size, val);
+
+        if (size == 4) {
+            *(uint32_t *) loc = val;
+        } else if (size == 8) {
+            *(uint64_t *) loc = val;
+        } else
+            die("Invalid relocation size");
+
+        // Fixme OLD section
+
+        rela->dest = 0;
+    }
+
+    for (unsigned r = 0; r < relocations_count; r++) {
+        if (relocations[r].dest == 0) continue; // already handled
+
+        printf("kpatch_relocation: name:%s/%s objname:%s type=%d, external=%d, *%p = ... (SHOULD NOT HAPPEN)\n",
+               relocations[r].ksym->objname, relocations[r].ksym->name,
+               relocations[r].objname, relocations[r].type, relocations[r].external,
+               (void *)relocations[r].dest);
+        // Fixme OLD section
+        assert(false && "All relocations should have been handleded above");
+    }
+
+}
+
+
+
+////////////////////////////////////////////////////////////////
+// Patching Thread and API
+static pthread_t wf_patch_thread;
+static pthread_cond_t wf_cond_initiate;
+
+/* Environment Variables - Start */
+// WF_GLOBAL
+
+// WF_GROUP
+//static bool wf_is_group_quiescence;
+static char *wf_group_quiescence;
+
+// WF_PATCH_ONLY_ACTIVE
+static bool wf_is_patch_only_active_threads;
+/* Environment Variables - End */
+int wf_amount_priorities = 0;
+int wf_trigger_sleep_ms = -1;
+int wf_log_quiescence_priority = 0;
+
+int wf_every_action_delay_ms = 0;
+
+struct patch_measurement {
+    double latency_as;
+    double latency_as_time;
+    double latency_migration;
+    double latency_migration_time;
+    int pte_size_kB;
+};
+struct patch_measurement *latencies = NULL;
+int page_table_size(int);
+
+
+#define METHOD_NOTHING 0
+#define METHOD_GLOBAL 1
+#define METHOD_LOCAL 2
+#define METHOD_TOTAL_METHODS 3
+
+char *get_patch_method_name(int method) {
+    switch (method) {
+        case METHOD_NOTHING: return "Nothing";
+        case METHOD_GLOBAL: return "Global Quiescence";
+        case METHOD_LOCAL: return "Local Quiescence";
+        default: return "Unknown";
+    }
+}
+
+
+double calculate_time(struct timespec *start) {
+    return start->tv_sec * 1000. + start->tv_nsec / 1000000.;
+}
+
+double calculate_latency(struct timespec *start, struct timespec *end) {
+    return (end->tv_sec - start->tv_sec) * 1000. + (end->tv_nsec - start->tv_nsec) / 1000000.;
+}
+
+
+
+static double wf_timestamp_start_quiescence;
+
+/* Stores the current state of the thread.
+ *
+ *  Transitations that will have an effect (all other are irgnoed):
+ *  ---------
+ *  | Start |
+ *  ---------
+ *     |
+ *    \ /
+ * ---------
+ * | Birth |--------------------------------
+ * ---------                               |
+ *    |                                    |
+ *   \ /                                  \ /
+ * ---------------   -------------     ---------
+ * | Deactivated |<->| Activated |---->| Death |
+ * ---------------   -------------     ---------
+ *      |                                 /\
+ *      |                                 |
+ *      -----------------------------------
+ * Start -> Birth
+ * Birth -> Death
+ * Birth -> Deactivated
+ * Deactivated -> Activated
+ * Deactivated -> Death
+ * Activated -> Deactivated
+ * Activated -> Death
+ * */
+typedef enum {
+    WF_LOCAL_THREAD_STATE_START,
+    WF_LOCAL_THREAD_STATE_BIRTH,
+    WF_LOCAL_THREAD_STATE_ACTIVATED,
+    WF_LOCAL_THREAD_STATE_DEACTIVATED,
+    WF_LOCAL_THREAD_STATE_DEATH,
+} wf_local_thread_state_t;
+
+typedef struct {
+    char *name;
+
+    pthread_mutex_t mutex;
+    pthread_cond_t cond_from_threads;
+    pthread_cond_t cond_to_threads;
+
+    volatile int born_threads;
+    volatile int active_threads;
+    volatile int migrated_threads;
+
+    volatile int as;
+    volatile int target_generation;
+    volatile int previous_as;
+} wf_group;
+
+typedef struct {
+  int id;
+  pthread_t pthread_id;
+
+  wf_group *group; // Point to a group (group shared between threads)
+
+  char *name;
+  volatile wf_local_thread_state_t state;
+
+  volatile int current_generation;
+  volatile int current_as;
+
+  volatile bool in_global_quiescence;
+
+  volatile int external_priority;
+} wf_thread;
+
+
+static volatile wf_group wf_master_group; // Every thread updates this
+
+static __thread wf_thread wf_local_thread = {
+    .state = WF_LOCAL_THREAD_STATE_START,
+    .in_global_quiescence = false,
+    .external_priority = -1
+};
+pthread_mutex_t wf_all_threads_mutex;
+static wf_thread *wf_all_threads[1000] = { NULL };
+static volatile int wf_total_threads = 0;
+
+static volatile int thread_unique_id_counter = 0; // A global counter that only increments. Used to get a unique  wf_local_thread_id to access threads_to_wakeup
+
+// WF_GROUP
+static pthread_mutex_t wf_mutex_groups;
+static volatile wf_group wf_groups[20];
+static volatile int wf_groups_size = 0;
+
+// Current WF_STATE
+typedef enum {
+    IDLE,
+    IN_PROGRESS,
+} wf_state_t;
+static volatile wf_state_t wf_state;
+
+
+pthread_cond_t cond_trigger_patching;
+
+int msleep(long msec)
+{
+    if (msec <= 0)
+        return -1;
+
+    struct timespec ts;
+    int res;
+
+    if (msec < 0)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ts.tv_sec = msec / 1000;
+    ts.tv_nsec = (msec % 1000) * 1000000;
+
+    do {
+        res = nanosleep(&ts, &ts);
+    } while (res && errno == EINTR);
+
+    return res;
+}
+
+int wf_get_local_thread_id() {
+    return wf_local_thread.id;
+}
+
+int wf_amount_patching_threads() {
+    if (wf_is_patch_only_active_threads) {
+        return wf_local_thread.group->active_threads;
+    } else {
+        return wf_local_thread.group->born_threads;
+    }
+}
+
+wf_group *wf_find_group(char *group) {
+    pthread_mutex_lock(&wf_mutex_groups);
+    for (int i = 0; i < wf_groups_size; i++) {
+        if (strcmp(group, wf_groups[i].name) == 0) {
+            pthread_mutex_unlock(&wf_mutex_groups);
+            return &wf_groups[i];
+        }
+    }
+    pthread_mutex_unlock(&wf_mutex_groups);
+    return NULL;
+}
+
+void wf_set_group(char *group) {
+    if (wf_local_thread.group != NULL)
+        return;
+
+    // Use master group if:
+    // - no group is set (group == NULL)
+    if (group == NULL)
+        wf_local_thread.group = &wf_master_group;
+    
+    if (wf_local_thread.group == NULL)
+         wf_local_thread.group = wf_find_group(group);
+    
+    // Still no group found. Create a new group 
+    if (wf_local_thread.group == NULL) {
+        pthread_mutex_lock(&wf_mutex_groups);
+    
+        wf_groups[wf_groups_size].name = group;
+        wf_groups[wf_groups_size].born_threads = 0;
+        wf_groups[wf_groups_size].active_threads = 0;
+        wf_groups[wf_groups_size].migrated_threads = 0;
+        wf_groups[wf_groups_size].target_generation = 0;
+        
+        wf_local_thread.group = &wf_groups[wf_groups_size];
+        wf_groups_size++;
+        
+        pthread_mutex_unlock(&wf_mutex_groups);
+    }
+}
+
+// WF_PATCH_QUEUE
+char *wf_patch_queue = NULL;
+int wf_patch_method = 0;
+
+bool wf_load_patch(void) {
+    char *patch = NULL;
+    
+    if (wf_patch_queue && *wf_patch_queue) {
+        double time_patch_start = wf_timestamp();
+
+        char *patch_stack = wf_patch_queue;
+        char *p = strchr(wf_patch_queue, ';');
+        if (p) { *p = 0; wf_patch_queue = p + 1;}
+        else   { wf_patch_queue = 0; };
+
+        char *patch_stack_cpy = strdup(patch_stack);
+        log("applying patch: %s\n", patch_stack);
+        char *saveptr = NULL;
+        char *patch;
+        p = patch_stack;
+        while (patch = strtok_r(p, ",", &saveptr)) {
+            p = NULL;
+            if (strchr(patch, '*')){
+                log("loading patch glob: %s\n", patch);
+                glob_t globbuf;
+                if (glob(patch, 0, NULL, &globbuf) != 0) {
+                    die("glob failed: %s\n", patch);
+                }
+                for (unsigned i = 0; i < globbuf.gl_pathc; i++) {
+                    log("loading patch: %s\n", globbuf.gl_pathv[i]);
+                    wf_load_patch_from_file(globbuf.gl_pathv[i]);
+                }
+                globfree(&globbuf);
+            } else {
+                log("loading patch: %s\n", patch);
+                wf_load_patch_from_file(patch);
+            }
+        }
+
+        wf_log("- [patched, %.4f, \"%s\", \"%s\"]\n",
+               wf_timestamp() - time_patch_start, patch_stack_cpy, wf_local_thread.group->name);
+        free(patch_stack_cpy);
+
+        if (wf_config.patch_applied)
+            wf_config.patch_applied();
+
+        return true;
+    }
+    return false;
+}
+
+void wf_trigger_patch(void);
+
+static int wf_config_get(char * name, int default_value) {
+    char *env = getenv(name);
+    if (!env) return default_value;
+    char *ptr;
+    long ret;
+    ret = strtol(env, &ptr, 10);
+    if (!ptr || *ptr != '\0') die("invalid env config %s: %s", name, env);
+    return (int) ret;
+}
+
+void wf_signal_patching(void) {
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) == 0)
+        pthread_cond_signal(&cond_trigger_patching);
+}
+
+void wf_signal_patching_and_quiescence(void) {
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) != 0)
+        return;
+
+    wf_signal_patching();
+    
+    // Only useful for global quiescence, i.e. the thread immediately waits in its barrier
+    // such that the patch can be applied immediately.
+    // For local quiescence, as_switch is executed. If the patcher process is slower (what it is),
+    // no new as generation is ready yet. Do do not use it with local quiescence.    
+    if (wf_patch_method == METHOD_GLOBAL) 
+        // We wake the patcher thread until its state is not idle anymore (i.e. it prepares the patch)
+        // Otherwise, a signal may be lost..
+        while (wf_state == IDLE)
+            wf_signal_patching();
+        wf_global_quiescence();
+}
+
+static double wf_config_get_double(char * name, double default_value) {
+    char *env = getenv(name);
+    if (!env) return default_value;
+    char *ptr;
+    double ret;
+    ret = strtod(env, &ptr);
+    if (!ptr || *ptr != '\0') die("invalid env config %s: %s", name, env);
+    return ret;
+}
+
+double time_diff(struct timespec now, struct timespec future) {
+    return ( future.tv_sec - now.tv_sec )
+        +  ( future.tv_nsec - now.tv_nsec ) / 1E9;
+}
+
+
+
+
+// START FIFO
+// FIFO original source code:
+// Post: https://osg.tuhh.de/Advent/12-postbox/
+// https://collaborating.tuhh.de/e-exk4/advent/-/blob/solution_12/12-postbox/postbox.c
+// and https://collaborating.tuhh.de/e-exk4/advent/-/blob/solution_12/12-postbox/fifo.c
+static void epoll_add(int epoll_fd, int fd, int events) {
+    struct epoll_event ev;
+    ev.events   = events;
+    ev.data.fd  = fd;
+
+    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &ev) == -1) {
+        die("epoll_ctl: activate");
+    }
+}
+
+static void epoll_del(int epoll_fd, int fd) {
+    if (epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL) == -1) {
+        die("epoll_ctl: reset");
+    }
+}
+
+static int open_fifo(char *fifo) {
+    int fd = open(fifo, O_RDONLY|O_NONBLOCK);
+    if (fd < 0) die("open/fifo");
+    return fd;
+}
+
+static int fifo_prepare(char *fifo, int epoll_fd) {
+    int rc = unlink(fifo);
+    if (rc < 0 && errno != ENOENT) die("unlink/fifo");
+    rc = mknod(fifo, 0666 | S_IFIFO, 0);
+    if (rc < 0) die("mknod/fifo");
+
+    int fifo_fd = open_fifo(fifo);
+    epoll_add(epoll_fd, fifo_fd, EPOLLIN);
+
+    return fifo_fd;
+}
+
+static pthread_mutex_t mutex_patch_queue;
+
+static void* wf_patch_thread_entry(void *arg) {
+    wf_set_group(wf_group_quiescence);
+
+    for(;;) {
+        pthread_mutex_lock(&mutex_patch_queue);
+        // No patch ready. Prevent from spurious wake
+        while (!(wf_patch_queue && *wf_patch_queue) ) {
+            pthread_cond_wait(&cond_trigger_patching, &mutex_patch_queue);
+        }
+        pthread_mutex_unlock(&mutex_patch_queue);
+        wf_trigger_patch();
+    }
+}
+
+static void* wf_patch_thread_entry2(void *arg) {
+    if (getenv("WF_PATCH_TRIGGER_FIFO") == NULL) {
+        // Disable patching...
+        wf_log("!!! PATCHING DISABLED !!!\n");
+        return;
+    }
+    
+    wf_set_group(wf_group_quiescence);
+
+    int epoll_fd = epoll_create1(0);
+    if (epoll_fd == -1) die("epoll_create");
+
+    int fifo_fd = fifo_prepare(getenv("WF_PATCH_TRIGGER_FIFO"), epoll_fd);
+    
+    // REDIS SPECIFICS:
+    int latency_counter = 0;
+    struct timespec start;
+    struct timespec end;
+    double latency_create_ms = -1;
+    double latency_create_time = -1;
+    double latency_migrate_ms = -1;
+    double latency_migrate_time = -1;
+    // ------------------
+
+    for(;;) {
+        struct epoll_event event[1];
+        int nfds = epoll_wait(epoll_fd, event, 1, -1);
+        int fd = event[0].data.fd;
+        if (fd == fifo_fd) {
+            static char buf[128];
+            if (event[0].events & EPOLLIN) {
+                int len = read(fifo_fd, buf, sizeof(buf));
+                if (len < 0) die("read/fifo");
+                if (len == 0) goto close;
+                while (len > 1 && buf[len-1] == '\n') len --;
+                buf[len] = 0;
+                int pte_size_kB = page_table_size(latency_counter);
+                if (strcmp(buf, "1") == 0) {
+                    wf_trigger_patch();
+                } else if (strcmp(buf, "2") == 0) {
+                    // New AS every X seconds..
+                    for(;;) {
+                        double time_start_kernel_as_new = wf_timestamp();
+                        wf_kernel_as_new();
+                        wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
+                         msleep(wf_every_action_delay_ms);
+                    }
+                } else if (strcmp(buf, "3") == 0) {
+                    // New AS + Migrate every X seconds..
+                    for(;;) {
+                        // Create
+                        double time_start_kernel_as_new = wf_timestamp();
+                        int as = wf_kernel_as_new();
+                        wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
+                        
+                        // Switch
+                        double time_start_kernel_as_switch = wf_timestamp();
+                        wf_kernel_as_switch(as);
+                        wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
+                        msleep(wf_every_action_delay_ms);
+                    }
+                } else if (strcmp(buf, "4") == 0) {
+                    // Create new AS once and switch between old and new all the time..
+                    int old_as = syscall(1000, 2);
+                    int new_as = wf_kernel_as_new();
+                    int current_as = old_as;
+                    for (;;) {
+                        double time_start_kernel_as_switch = wf_timestamp();
+                        if (old_as == current_as) {
+                            wf_kernel_as_switch(new_as);
+                            current_as = new_as;
+                        } else {
+                            wf_kernel_as_switch(old_as);
+                            current_as = old_as;
+                        }
+                        wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
+                        msleep(wf_every_action_delay_ms);
+                    }
+                // REDIS EXPERIMENTS:
+                } else if (strcmp(buf, "5") == 0) {
+                    // Create new AS
+                    clock_gettime(CLOCK_REALTIME, &start);
+                    int as = wf_kernel_as_new(); 
+                    clock_gettime(CLOCK_REALTIME, &end);
+
+                    latency_create_ms = calculate_latency(&start, &end);
+                    latency_create_time = calculate_time(&start);
+                } else if (strcmp(buf, "6") == 0) {
+                    // Fork
+                    clock_gettime(CLOCK_REALTIME, &start);
+                    if (fork() == 0) {
+                        exit(0);
+                    }
+                    clock_gettime(CLOCK_REALTIME, &end);
+
+                    latency_create_ms = calculate_latency(&start, &end);
+                    latency_create_time = calculate_time(&start);
+                } else if (strcmp(buf, "7") == 0) {
+                    // Write results
+                    char *logfile = getenv("WF_LOGFILE");
+                    char *resultfile = malloc(strlen(logfile) + strlen(".csv"));
+                    strcat(resultfile, logfile);
+                    strcat(resultfile, ".csv");
+
+                    FILE *resultfile_fp = fopen(resultfile, "w+");
+                    fprintf(resultfile_fp, "latency_kernel_ms, latency_kernel_time, latency_switch_ms, latency_switch_time,pte_size_kB\n");
+                    for (int i = 0; i < latency_counter; i++) {
+                        struct patch_measurement m = latencies[i];
+                        fprintf(resultfile_fp, "%f,%f,%f,%f,%d\n", m.latency_as, m.latency_as_time, m.latency_migration, m.latency_migration_time, m.pte_size_kB);
+                    }
+                fflush(resultfile_fp);
+                fclose(resultfile_fp);
+                }
+                latencies[latency_counter] = (struct patch_measurement) {.latency_as = latency_create_ms, .latency_as_time = latency_create_time, .latency_migration = latency_migrate_ms, .latency_migration_time = latency_migrate_time, .pte_size_kB = pte_size_kB};
+                latency_counter++;
+            } else if (event[0].events & EPOLLHUP) {
+close:
+                epoll_del(epoll_fd, fifo_fd);
+                close(fifo_fd);
+
+                fifo_fd = open_fifo(getenv("WF_PATCH_TRIGGER_FIFO"));
+                epoll_add(epoll_fd, fifo_fd, EPOLLIN);
+            }
+        }
+    }
+    return NULL;
+}
+
+// END FIFO
+
+static void wf_log_reach_quiescence_point() {
+    wf_log("- [reach-quiescence-point, %.4f, \"%s\", \"%s\", %d]\n",
+            wf_timestamp() - wf_timestamp_start_quiescence, wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id);
+}
+
+static void wf_log_migrated() {
+    wf_log("- [migrated, %.4f, %d, \"%s\", \"%s\", %d]\n",
+            wf_timestamp() - wf_timestamp_start_quiescence, wf_local_thread.current_as, wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id);
+}
+
+
+void patch_global_quiescence() {
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    wf_local_thread.group->migrated_threads = 0;
+
+    wf_timestamp_start_quiescence = wf_timestamp();
+    wf_state = IN_PROGRESS;
+    wf_local_thread.group->target_generation++;
+
+    // Some Applications need a trigger to reach global quiescence
+    if (wf_config.trigger_global_quiescence) {
+        int trigger_counter = 0;
+        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
+            pthread_mutex_unlock(&wf_local_thread.group->mutex);
+            if (wf_config.trigger_global_quiescence(trigger_counter++) == 0) {
+                pthread_mutex_lock(&wf_local_thread.group->mutex);
+                break;
+            }
+            msleep(wf_trigger_sleep_ms);
+            pthread_mutex_lock(&wf_local_thread.group->mutex);
+        }
+    }
+
+    while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
+        pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
+    ////////////////////////////////////////////////////////////////
+    wf_log("- [quiescence, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
+
+    // Load and Apply the patch
+    wf_load_patch();
+
+    wf_state = IDLE;
+    ////////////////////////////////////////////////////////////////
+    // Let's leave the global quiescence point
+    wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
+    pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping threads
+    ////////////////////////////////////////////////////////////////
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+}
+
+void patch_local_quiescence(void) {
+    double time_start_kernel_as_new = wf_timestamp();
+    int new_as = wf_kernel_as_new();
+    wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
+
+    double time_start_kernel_as_switch = wf_timestamp();
+    wf_kernel_as_switch(new_as);
+    wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
+
+    wf_local_thread.current_as = new_as;
+
+    // Load and Apply the patch
+    wf_load_patch();
+    
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    wf_local_thread.group->migrated_threads = 0;
+    wf_local_thread.group->previous_as = wf_local_thread.group->as;
+    wf_local_thread.group->as = new_as;
+    ////////////////////////////////////////////////////////////////
+    wf_timestamp_start_quiescence = wf_timestamp();
+    wf_state = IN_PROGRESS;
+    wf_local_thread.group->target_generation++;
+
+    // Some applications require a trigger to reach local quiescence
+    if (wf_config.trigger_local_quiescence) {
+        int trigger_counter = 0;
+        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
+            pthread_mutex_unlock(&wf_local_thread.group->mutex);
+            if (wf_config.trigger_local_quiescence(trigger_counter++) == 0) { 
+                pthread_mutex_lock(&wf_local_thread.group->mutex);
+                break;
+            }
+            msleep(wf_trigger_sleep_ms);
+            pthread_mutex_lock(&wf_local_thread.group->mutex);
+        }
+    }
+
+    while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
+        pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
+    
+    //if (wf_is_group_quiescence)
+        //pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping group threads
+    
+    wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
+    
+    // After successful migration of all threads, we try to delete
+    // the previous address-space generation
+    double time_wf_kernel_as_delete = wf_timestamp();
+    wf_kernel_as_delete(wf_local_thread.group->previous_as);
+    wf_log("- [address-space-delete, %.4f, \"%s\"]\n", wf_timestamp() - time_wf_kernel_as_delete, wf_local_thread.group->name);
+
+    wf_state = IDLE;
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+}
+
+void wf_trigger_patch(void) {
+    static int first = 0;
+    if (!first) first = 1;
+    else wf_log("---\n");
+    
+    // Print statistics about the current VMAs BEFORE time measurement starts 
+    count_vmas("before");
+    page_table_size(first);
+
+    // Reset the time
+    wf_timestamp_reset();
+    
+    wf_log("- [apply, %ld.%09ld, %s, %d, \"%s\"]\n",
+           wf_ts0.tv_sec,
+           wf_ts0.tv_nsec,
+           get_patch_method_name(wf_patch_method),
+           wf_amount_patching_threads(),
+           wf_local_thread.group->name
+        );
+    
+    if (wf_patch_method == METHOD_GLOBAL) {
+        patch_global_quiescence();
+    } else if (wf_patch_method == METHOD_LOCAL) {
+        patch_local_quiescence();
+    }
+    count_vmas("after");
+}
+
+
+bool check_if_quiescence() {
+    if (wf_state == IDLE)
+        return false;
+    if (wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
+        if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_BIRTH ||
+                wf_local_thread.state == WF_LOCAL_THREAD_STATE_ACTIVATED)
+            return true;
+    }
+    return false;
+}
+
+bool wf_allow_priority_quiescence();
+bool wf_quiescence(void) {
+    // Quiescence is always true because we do not apply any patches..
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) != 0)
+        return true;
+
+    if (!check_if_quiescence())
+        return false;
+    
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+
+    bool res = false;
+    if (wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
+        double start = wf_timestamp();
+        if (wf_patch_method == METHOD_GLOBAL)
+            res = wf_global_quiescence();
+        else if (wf_patch_method == METHOD_LOCAL)
+            res = wf_local_quiescence();
+        double end = wf_timestamp();
+        wf_log("- [e2e-patch, %ld.%09ld, %.4f, %d, \"%s\"]\n", ts.tv_sec, ts.tv_nsec, end - start, wf_patch_method, wf_local_thread.group->name);
+   }
+    return res;
+}
+
+bool wf_global_quiescence(void) {
+    // every global quiescence point is also an local quiescence point
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    if (!wf_allow_priority_quiescence()) {
+      pthread_mutex_unlock(&wf_local_thread.group->mutex);
+      return false;
+    }
+    wf_log_reach_quiescence_point();
+    wf_local_thread.group->migrated_threads++;
+    wf_local_thread.in_global_quiescence = true;
+    wf_local_thread.current_generation = wf_local_thread.group->target_generation;
+    
+    // Scenario: GLOBAL_QUIESCENCE is performed while new threads are spawining.
+    // Patch application is performed and worker_thread releases lock. New threads 
+    // arrive here and wait for the signal, which will "never" arrive as patch application
+    // is already finished.
+    if (wf_state != IDLE) {
+        // Signal that one thread has reached the barrier
+        if (wf_config.thread_migrated) {
+            int remaining = wf_amount_patching_threads() - wf_local_thread.group->migrated_threads;
+            wf_config.thread_migrated(remaining);
+        }
+        
+        if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads()) {
+            pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
+        }
+        // BLOCK: Wait for patcher thread to respond
+        pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
+        wf_local_thread.in_global_quiescence = false;
+    }
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    return true;
+}
+
+bool wf_local_quiescence(void) {
+    // Migrate as soon as a new version exists
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    int as = wf_local_thread.group->as;
+    int target_generation = wf_local_thread.group->target_generation;
+    wf_local_thread.in_global_quiescence = true;
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+
+    wf_log_reach_quiescence_point();
+    wf_kernel_as_switch(as);
+    wf_log_migrated();
+
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    wf_local_thread.current_generation = target_generation;
+    wf_local_thread.current_as = as;
+
+    wf_local_thread.group->migrated_threads++;
+
+    if (wf_config.thread_migrated) {
+        int remaining = wf_amount_patching_threads() - wf_local_thread.group->migrated_threads;
+        // printf("remaining: %s %d\n", name, remaining);
+        wf_config.thread_migrated(remaining);
+    }
+    if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads()) {
+        // last thread; wakeup patcher thread
+        pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
+    }
+    
+    //if (wf_is_group_quiescence) {
+        // Group quiescence is a form of global quiescence, but just for a group.
+        // So block the group and wait for all threads to be migrated
+        //pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
+    //}
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    return true;
+}
+
+#define OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED NULL
+#define OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED_FINISHED NULL
+#define OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED NULL
+#define OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED_FINISHED NULL
+
+//#define OUTPUT_WF_LOCAL_THREAD_INVALID_STATE 1
+
+void wf_log_thread_status(char *message) {
+    if (message)
+        wf_log("- [%s, %.2f, \"%s\", \"%s\", %d]\n", message, wf_timestamp(), wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id);
+}
+
+
+void wf_try_signal_thread_amount_changed(int amount_threads_added_removed) {
+  if (wf_state != IDLE) { // Patcher thread is perfomring some action
+      if (wf_local_thread.current_generation == wf_local_thread.group->target_generation)
+          wf_local_thread.group->migrated_threads += amount_threads_added_removed;
+      if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads())
+          pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
+  }
+}
+
+/* Start of thread. SHould only be called once, otherwise use wf_thread_activate(). */
+void wf_thread_birth_group(char *name, char*group) {
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_START) {
+        wf_set_group(group);
+
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+
+        wf_local_thread.id = thread_unique_id_counter++;
+        pthread_mutex_lock(&wf_all_threads_mutex);
+        wf_total_threads++;
+        wf_all_threads[wf_local_thread.id] = &wf_local_thread;
+        pthread_mutex_unlock(&wf_all_threads_mutex);
+
+        wf_local_thread.pthread_id = pthread_self();
+        wf_local_thread.name = name;
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_BIRTH;
+        
+        wf_log_thread_status("birth");
+
+        // Change name of thread for better debugging...
+        char new_thread_name[16];
+        sprintf(new_thread_name, "%d", wf_local_thread.id);
+        pthread_setname_np(pthread_self(), new_thread_name);
+
+        wf_local_thread.group->born_threads++;
+        wf_local_thread.group->active_threads++;
+        
+        wf_try_signal_thread_amount_changed(1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+
+        wf_quiescence();
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_birth(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
+    }
+}
+
+/* Start of thread. SHould only be called once, otherwise use wf_thread_activate(). */
+void wf_thread_birth(char *name) {
+    wf_thread_birth_group(name, NULL);    
+}
+
+/* Thread will be considered for patching */
+void wf_thread_activate(void) {
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED);
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_DEACTIVATED) {
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+        
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_ACTIVATED;
+        wf_local_thread.group->active_threads++;
+
+        if (wf_is_patch_only_active_threads)
+          wf_try_signal_thread_amount_changed(1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_activate(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
+    }
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED_FINISHED);
+}
+
+/* End of thread. SHould only be called once, otherwise use wf_thread_deactivate(). */
+void wf_thread_death(void) {
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_BIRTH ||
+            wf_local_thread.state == WF_LOCAL_THREAD_STATE_ACTIVATED ||
+            wf_local_thread.state == WF_LOCAL_THREAD_STATE_DEACTIVATED) {
+
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+
+        pthread_mutex_lock(&wf_all_threads_mutex);
+        wf_total_threads--;
+        wf_all_threads[wf_local_thread.id] = NULL;
+        pthread_mutex_unlock(&wf_all_threads_mutex);
+
+        wf_local_thread.group->born_threads--;
+        if (wf_local_thread.state != WF_LOCAL_THREAD_STATE_DEACTIVATED)
+            wf_local_thread.group->active_threads--;
+
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_DEATH;
+
+        wf_try_signal_thread_amount_changed(-1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_death(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
+    }
+    wf_log_thread_status("death");
+}
+
+/* Thread won't be considered for patching anymore */
+void wf_thread_deactivate(void) {
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED);
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_BIRTH ||
+            wf_local_thread.state == WF_LOCAL_THREAD_STATE_ACTIVATED) {
+
+        // wf_global_quiescence(); // Thread is not dead (yet). Check patch.
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+
+        wf_local_thread.group->active_threads--;
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_DEACTIVATED;
+
+        if (wf_is_patch_only_active_threads)
+          wf_try_signal_thread_amount_changed(-1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_deactivate(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
+    }
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED_FINISHED);
+}
+
+int wf_find_lowest_priority(bool in_global_quiescence) {
+  for (int priority = 0; priority < wf_amount_priorities; priority++) {
+    for (int i = 0; i < wf_total_threads; i++) {
+      if (wf_all_threads[i]) {
+        if (wf_all_threads[i]->group != wf_local_thread.group)
+          continue;
+
+        if (wf_all_threads[i]->in_global_quiescence == in_global_quiescence && wf_all_threads[i]->external_priority == priority) {
+          return priority;
+        }
+      }
+    }
+  }
+  return -1;
+}
+
+bool wf_allow_priority_quiescence() {
+  if (wf_state != IDLE) {
+    // Quiescence in progress
+    pthread_mutex_lock(&wf_all_threads_mutex);
+    int lowest_priority_not_in_quiescence = wf_find_lowest_priority(false);
+    int lowest_priority_in_quiescence = wf_find_lowest_priority(true);
+    pthread_mutex_unlock(&wf_all_threads_mutex);
+
+    // No priority used/set at all. Quiescence is fine.
+    if (lowest_priority_not_in_quiescence == -1 && lowest_priority_in_quiescence == -1)
+      return true;
+
+    // Higher or equal priorities are already in quiescence, so its fine to also quiescence.
+    if (lowest_priority_in_quiescence >= wf_local_thread.external_priority)
+      return true;
+
+    // Only higher priorities remain (not in quiescence). All other threads have at least same priority,
+    // so it is fine to quiescence.
+    if (lowest_priority_not_in_quiescence >= wf_local_thread.external_priority)
+      return true;
+    
+    if (wf_log_quiescence_priority) {
+        wf_log("- [no-quiescence-priority, %.4f, \"%s\", \"%s\", %d, Own: %d, Lowest Q: %d, Lowest !Q: %d]\n",
+               wf_timestamp(), wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id,
+               wf_local_thread.external_priority, lowest_priority_in_quiescence, lowest_priority_not_in_quiescence);
+    }
+
+    return false;
+  }
+}
+
+void wf_thread_set_priority(int priority) {
+  pthread_mutex_lock(&wf_local_thread.group->mutex);
+  wf_local_thread.external_priority = priority;
+  pthread_mutex_unlock(&wf_local_thread.group->mutex);
+}
+
+void wf_set_patch(char *patch) {
+    if (patch) {
+        pthread_mutex_lock(&mutex_patch_queue);
+        wf_patch_queue = strdup(patch);
+        wf_log("- [Patch, \"%s\"]\n", wf_patch_queue);
+        pthread_mutex_unlock(&mutex_patch_queue);
+    }
+}
+
+void wf_set_patch_method(int method) {
+    if (method < 0 || method >= METHOD_TOTAL_METHODS) {
+        fprintf(stderr, "Invalid patch method used: %d!\n", method);
+        return;
+    }
+    wf_patch_method = method;
+    wf_log("- [PatchMethod, \"%s\"]\n", get_patch_method_name(method));
+}
+
+void wf_init(struct wf_configuration config) {
+    wf_amount_priorities = config.amount_priorities;
+    wf_trigger_sleep_ms = wf_config_get("WF_TRIGGER_SLEEP_MS", config.trigger_sleep_ms);
+    wf_log_quiescence_priority = wf_config_get("WF_LOG_QUIESCENCE_PRIORITY", wf_log_quiescence_priority);
+    
+    wf_every_action_delay_ms = wf_config_get("WF_EVERY_ACTION_DELAY_MS", 0);
+    latencies = calloc(1000, sizeof(struct patch_measurement));
+
+    wf_patch_method = wf_config_get("WF_PATCH_METHOD", 0);
+   
+    int wf_patch_only_active = wf_config_get("WF_PATCH_ONLY_ACTIVE", 0);
+    wf_is_patch_only_active_threads = wf_patch_only_active == 0 ? false : true;
+
+    //char *group_quiescence = getenv("WF_GROUP");
+    //if (group_quiescence == NULL) {
+        //wf_is_group_quiescence = false;
+    //} else {
+        //wf_is_group_quiescence = true;
+        //wf_group_quiescence = group_quiescence;
+    //}
+    
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) != 0) {
+        // Do not load symbols if we don't want to patch. So we can also use a regular kernel ;-)
+        // On a regular kernel, this call fails otherwise
+    } else {
+        wf_load_symbols("/proc/self/exe");
+    }
+
+    pthread_condattr_t attr;
+    pthread_condattr_init(&attr);
+    pthread_condattr_setclock(&attr, CLOCK_REALTIME);
+    pthread_cond_init(&wf_cond_initiate, &attr);
+
+    // Copy(!) away the configuration that we got from the
+    // configuration
+    wf_config = config;
+
+    char *logfile = getenv("WF_LOGFILE");
+    if (logfile) {
+        log("opening wf logfile: %s\n", logfile);
+        wf_log_file = fopen(logfile, "w+");
+    } else {
+        wf_log_file = stderr;
+    }
+
+    // Load the patch queue, if possible
+    char *queue = getenv("WF_PATCH_QUEUE");
+    if (queue) wf_patch_queue = strdup(queue);
+
+    // We start a thread that does all the heavy lifting of address
+    // space management
+    if ((errno = pthread_create(&wf_patch_thread, NULL,
+                                &wf_patch_thread_entry, NULL)) != 0) {
+        perror("pthread_create");
+    }
+
+    pthread_setname_np(wf_patch_thread, "wf-patcher");
+
+    count_vmas("startup");
+}
+
+// ############################################ //
+// ############### VMA COUNT ################## //
+// ############################################ //
+
+typedef struct {
+    long shared_clean;
+    long shared_dirty;
+    long private_clean;
+    long private_dirty;
+    long size;
+
+    int count;
+
+    char *perms;
+
+    int is_anon;
+    int is_file_backed;
+} vma_count;
+
+static int count_vmas_amount_perms = 16;
+
+static void count_vmas_init_vma_count(vma_count vma_count_list[]) {
+    char *perms[] = {
+        "---p", "---s",
+        "r--p", "r--s",
+        "-w-p", "-w-s",
+        "--xp", "--xs",
+        "rw-p", "rw-s",
+        "r-xp", "r-xs",
+        "-wxp", "-wxs",
+        "rwxp", "rwxs"
+    };
+
+    for (int i = 0; i < count_vmas_amount_perms; i++) {
+        memset(&vma_count_list[i], 0, sizeof(vma_count)); // All variables to 0
+        vma_count_list[i].is_anon = 1;
+        vma_count_list[i].perms = perms[i];
+        
+        memset(&vma_count_list[i + count_vmas_amount_perms], 0, sizeof(vma_count)); // All variables to 0
+        vma_count_list[i + count_vmas_amount_perms].is_file_backed = 1;
+        vma_count_list[i + count_vmas_amount_perms].perms = perms[i];
+    }
+       
+}
+
+static vma_count *count_vmas_find_vma_count(vma_count vma_count_list[], char *perms, char *inode) {
+    int start;
+    int end;
+    if (strcmp(inode, "0") == 0) {
+        // Anonymous VMA
+        start = 0;
+    } else {
+        // File-Backed VMA
+        start = count_vmas_amount_perms;
+    }
+    end = start + count_vmas_amount_perms;
+
+    for (int i = start; i < end; i++) {
+        if (strcmp(vma_count_list[i].perms, perms) == 0)
+            return &vma_count_list[i];
+    }
+    return NULL;
+}
+
+/* Prints statistics about the VMA of the current process
+ * (/proc/self/smaps).
+ *
+ * It sums up the:
+ * Size, Shared Clean, Shared Dirty, Private Clean, Private Dirty
+ * memory for each group. A grouop consists of the tuple:
+ * permission (perms) and anonymous/file-backed VMA
+ *
+ * It also counts the number of VMAs for each group. 
+ *
+ * Only the groups where count > 0 are printed.
+ *
+ * Output format:
+ * -[vma-count, <WFPATCH-GENERATION>, <PERM>, (ANONYMOUS|FILE-BACKED), <COUNT>, \
+ *  <sum SIZE>, <sum SHARED CLEAN>, <sum SHARED DIRTY>, <sum PRIVATE CLEAN>, <sum PRIVATE DIRTY>]
+ * */
+static void count_vmas(char *output_suffix) {
+    if (wf_config_get("WF_MEASURE_VMA", 0) == 0)
+        return;
+
+    // Check VMA count
+    FILE *fp;
+    char *line = NULL;
+    size_t len = 0;
+    ssize_t read;
+
+    fp = fopen("/proc/self/smaps", "r");
+    if (fp == NULL) return;
+
+    vma_count vma_count_list[count_vmas_amount_perms * 2];
+    count_vmas_init_vma_count(vma_count_list);
+
+    char *const_size = "Size:";
+    char *const_shared_clean = "Shared_Clean:";
+    char *const_shared_dirty = "Shared_Dirty:";
+    char *const_private_clean = "Private_Clean:";
+    char *const_private_dirty = "Private_Dirty:";
+
+
+    regex_t header_regex;
+    int header_regex_result;
+    header_regex_result = regcomp(&header_regex, "^([0-9a-f]+-[0-9a-f]+) (....) ([0-9a-f]+) (..):(..) .*", REG_EXTENDED);
+    if (header_regex_result) {
+        fprintf(stderr, "Could not compile regex");
+        exit(1);
+    }
+
+    vma_count *current_state = NULL;
+    while ((read = getline(&line, &len, fp)) != -1) {
+        header_regex_result = regexec(&header_regex, line, 0, NULL, 0);
+        if (!header_regex_result) {
+            strtok(line, " ");
+            char *perms = strtok(NULL, " "); // Permission
+            strtok(NULL, " "); // Offset
+            strtok(NULL, " "); // Time
+            char *inode = strtok(NULL, " "); // inode
+
+            current_state = count_vmas_find_vma_count(vma_count_list, perms, inode);
+            current_state->count += 1;
+        } else if (header_regex_result == REG_NOMATCH && current_state) {
+            strtok(line, " ");
+            if (strncmp(const_size, line, strlen(const_size)) == 0) {
+                char *size = strtok(NULL, " ");
+                int vma_size = atoi(size);
+                current_state->size += vma_size;
+            } else if (strncmp(const_shared_clean, line, strlen(const_shared_clean)) == 0) {
+                char *size = strtok(NULL, " ");
+                int shared_clean = atoi(size);
+                current_state->shared_clean += shared_clean; 
+            } else if (strncmp(const_shared_dirty, line, strlen(const_shared_dirty)) == 0) {
+                char *size = strtok(NULL, " ");
+                int shared_dirty = atoi(size);
+                current_state->shared_dirty += shared_dirty;
+            } else if (strncmp(const_private_clean, line, strlen(const_private_clean)) == 0) {
+                char *size = strtok(NULL, " ");
+                int private_clean = atoi(size);
+                current_state->private_clean += private_clean;
+            } else if (strncmp(const_private_dirty, line, strlen(const_private_dirty)) == 0) {
+                char *size = strtok(NULL, " ");
+                int private_dirty = atoi(size);
+                current_state->private_dirty += private_dirty;
+            }
+        } else {
+            char msgbuf[100];
+            regerror(header_regex_result, &header_regex, msgbuf, sizeof(msgbuf));
+            fprintf(stderr, "Regex match failed: %s\n", msgbuf);
+            exit(1);
+        }
+    }
+
+    free(line);
+    fclose(fp);
+
+    for (int i = 0; i < count_vmas_amount_perms * 2; i++) {
+        vma_count ele = vma_count_list[i];
+
+        if (ele.count == 0) continue;
+        
+        wf_log("- [vma-count-%s, %d, %s, %s, %d, %d, %d, %d, %d, %d]\n",
+                output_suffix, wf_local_thread.group == NULL ? 0: wf_local_thread.group->target_generation,
+                ele.perms, ele.is_anon > 0 ? "ANONYMOUS": "FILE-BACKED", ele.count, ele.size, ele.shared_clean, ele.shared_dirty, ele.private_clean, ele.private_dirty);
+    }
+}
+
+char *trim(char *str) {
+    char *ptr = NULL;
+    // Start
+    while (*str == ' ' || *str == '\t' || *str == '\n') str++;
+    ptr = str + strlen(str) - 1;
+    // End
+    while (*ptr == ' ' || *ptr == '\t' || *ptr == '\n'){ *ptr = '\0' ; ptr--; } ;
+    return str;   
+}
+
+int page_table_size(int iteration) {
+     if (wf_config_get("WF_MEASURE_PTE", 0) == 0)
+        return;
+
+    FILE *fp = fopen("/proc/self/status", "r");
+    ssize_t read;
+    char *line = NULL;
+    size_t len = 0;
+    while ((read = getline(&line, &len, fp)) != -1 ) {
+        if (strncmp("VmPTE:", line, strlen("VmPTE:")) == 0) {
+            line = line + strlen("VmPTE:");
+            line = trim(line);
+            line[strlen(line) - strlen("kB")] = '\0';
+            line = trim(line);
+            wf_log("- [VmPTE-%d, %s]\n", iteration, line);
+            return atoi(line);
+        }
+    }
+}
+
diff --git a/src/wfpatch-userland/wf-userland.h b/src/wfpatch-userland/wf-userland.h
new file mode 100644
index 000000000..fd3f836ce
--- /dev/null
+++ b/src/wfpatch-userland/wf-userland.h
@@ -0,0 +1,75 @@
+#ifndef __WAITFREE_PATCHING_H
+#define __WAITFREE_PATCHING_H
+
+#include <signal.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+    
+// #define SIGPATCH (SIGRTMIN+0)
+
+typedef enum {
+    WF_LOW = 0,
+    WF_MEDIUM = 1,
+    WF_HIGH = 2,
+    WF_CRITICAL = 3,
+} wf_thread_priority;
+
+/*
+ In order to use the wait free patching mechanism, you have to
+ initialize and configure the library. This should be done at the beginning of your main function.
+
+ wf_init will install an signal handler for SIGPATCH and spawn a thread
+ that will coordinate the applying a patch when the signal was received[1].
+ */
+struct wf_configuration {
+    int amount_priorities;
+    int trigger_sleep_ms;
+    // Some applications require some extra triggering to reach global
+    // or local quiescence points. With these callbacks the library
+    // issues such an application kicking.
+    int (*trigger_global_quiescence)(int);
+    int (*trigger_local_quiescence)(int);
+
+    void (*thread_migrated)(int remaining);
+
+    // OPTIONAL: Is called after patching is done.
+    void (*patch_applied)(void);
+
+    // OPTIONAL: Is called after all threads are migrated
+    void (*patch_done)(void);
+};
+
+void wf_init(struct wf_configuration config);
+
+bool wf_quiescence(void);
+
+bool wf_local_quiescence(void);
+bool wf_global_quiescence(void);
+
+void wf_signal_patching(void);
+void wf_trigger_patch(void);
+
+//void wf_thread_birth_group(char *name, char *group);
+void wf_thread_birth(char *name);
+void wf_thread_death(void);
+
+void wf_thread_set_priority(int priority);
+
+void wf_thread_activate(void);
+void wf_thread_deactivate(void);
+
+int wf_get_local_thread_id();
+void wf_set_patch(char *patch);
+void wf_set_patch_method(int method);
+
+void wf_log(char *fmt, ...);
+double wf_time(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
-- 
2.30.2

