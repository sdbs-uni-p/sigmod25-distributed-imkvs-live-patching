diff --git a/src/wfpatch-userland/wf-userland.c b/src/wfpatch-userland/wf-userland.c
index 7aa343c2a..47d0776da 100644
--- a/src/wfpatch-userland/wf-userland.c
+++ b/src/wfpatch-userland/wf-userland.c
@@ -42,7 +42,7 @@ static struct wf_configuration wf_config;
 
 // WF_LOGFILE
 static FILE *wf_log_file;
-static void wf_log(char *fmt, ...) {
+void wf_log(char *fmt, ...) {
     if (wf_log_file) {
         va_list(args);
         va_start(args, fmt);
@@ -63,6 +63,12 @@ static double wf_timestamp(void) { // returns 0 seconds first time called
     return (ts.tv_sec - wf_ts0.tv_sec)*1000. + (ts.tv_nsec - wf_ts0.tv_nsec) / 1000000.;
 }
 
+double wf_time(void) {
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    return ts.tv_sec*1000. + ts.tv_nsec / 1000000.;
+}
+
 
 
 ////////////////////////////////////////////////////////////////
@@ -314,12 +320,14 @@ void * wf_vspace_reservere(uintptr_t bytes) {
     return wf_vspace_bump_ptr;
 }
 
+static Elf64_Ehdr * wf_load_elf(char *filename_raw, bool close_to_binary, void **elf_end) {
+    char filename[PATH_MAX];
+    if(!realpath(filename_raw, filename)) die_perror("realpath", "file: %s | error: %s\n", filename_raw, strerror(errno));
 
-static Elf64_Ehdr * wf_load_elf(char *filename, bool close_to_binary, void **elf_end) {
     int fd = open(filename, O_RDONLY);
     if (!fd) die_perror("open", "Could not open patch file: %s", filename);
 
-    // Mapt the whole file
+    // Map the whole file
     struct stat size;
     if (fstat(fd, &size) == -1) die_perror("fstat", "Could not determine size: %s\n", filename);
 
@@ -656,10 +664,9 @@ static pthread_cond_t wf_cond_initiate;
 
 /* Environment Variables - Start */
 // WF_GLOBAL
-static bool wf_is_global_quiescence;
 
 // WF_GROUP
-static bool wf_is_group_quiescence;
+//static bool wf_is_group_quiescence;
 static char *wf_group_quiescence;
 
 // WF_PATCH_ONLY_ACTIVE
@@ -681,6 +688,22 @@ struct patch_measurement {
 struct patch_measurement *latencies = NULL;
 int page_table_size(int);
 
+
+#define METHOD_NOTHING 0
+#define METHOD_GLOBAL 1
+#define METHOD_LOCAL 2
+#define METHOD_TOTAL_METHODS 3
+
+char *get_patch_method_name(int method) {
+    switch (method) {
+        case METHOD_NOTHING: return "Nothing";
+        case METHOD_GLOBAL: return "Global Quiescence";
+        case METHOD_LOCAL: return "Local Quiescence";
+        default: return "Unknown";
+    }
+}
+
+
 double calculate_time(struct timespec *start) {
     return start->tv_sec * 1000. + start->tv_nsec / 1000000.;
 }
@@ -780,18 +803,15 @@ static pthread_mutex_t wf_mutex_groups;
 static volatile wf_group wf_groups[20];
 static volatile int wf_groups_size = 0;
 
-
 // Current WF_STATE
 typedef enum {
     IDLE,
-    GLOBAL_QUIESCENCE,
-    LOCAL_QUIESCENCE,
+    IN_PROGRESS,
 } wf_state_t;
 static volatile wf_state_t wf_state;
 
-bool wf_is_quiescence() {
-    return wf_state != IDLE;
-}
+
+pthread_cond_t cond_trigger_patching;
 
 int msleep(long msec)
 {
@@ -847,14 +867,13 @@ void wf_set_group(char *group) {
 
     // Use master group if:
     // - no group is set (group == NULL)
-    // - when using global quiescence (wf_is_global_quiescence)
-    // - When no group quiescence is used
-    if (group == NULL || wf_is_global_quiescence || wf_group_quiescence == NULL)
+    if (group == NULL)
         wf_local_thread.group = &wf_master_group;
     
     if (wf_local_thread.group == NULL)
          wf_local_thread.group = wf_find_group(group);
     
+    // Still no group found. Create a new group 
     if (wf_local_thread.group == NULL) {
         pthread_mutex_lock(&wf_mutex_groups);
     
@@ -866,7 +885,6 @@ void wf_set_group(char *group) {
         
         wf_local_thread.group = &wf_groups[wf_groups_size];
         wf_groups_size++;
-
         
         pthread_mutex_unlock(&wf_mutex_groups);
     }
@@ -874,6 +892,7 @@ void wf_set_group(char *group) {
 
 // WF_PATCH_QUEUE
 char *wf_patch_queue = NULL;
+int wf_patch_method = 0;
 
 bool wf_load_patch(void) {
     char *patch = NULL;
@@ -922,11 +941,7 @@ bool wf_load_patch(void) {
     return false;
 }
 
-static void wf_initiate_patching(void);
-
-static void wf_sigpatch_handler(int sig) {
-    pthread_cond_signal(&wf_cond_initiate);
-}
+void wf_trigger_patch(void);
 
 static int wf_config_get(char * name, int default_value) {
     char *env = getenv(name);
@@ -938,6 +953,29 @@ static int wf_config_get(char * name, int default_value) {
     return (int) ret;
 }
 
+void wf_signal_patching(void) {
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) == 0)
+        pthread_cond_signal(&cond_trigger_patching);
+}
+
+void wf_signal_patching_and_quiescence(void) {
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) != 0)
+        return;
+
+    wf_signal_patching();
+    
+    // Only useful for global quiescence, i.e. the thread immediately waits in its barrier
+    // such that the patch can be applied immediately.
+    // For local quiescence, as_switch is executed. If the patcher process is slower (what it is),
+    // no new as generation is ready yet. Do do not use it with local quiescence.    
+    if (wf_patch_method == METHOD_GLOBAL) 
+        // We wake the patcher thread until its state is not idle anymore (i.e. it prepares the patch)
+        // Otherwise, a signal may be lost..
+        while (wf_state == IDLE)
+            wf_signal_patching();
+        wf_global_quiescence();
+}
+
 static double wf_config_get_double(char * name, double default_value) {
     char *env = getenv(name);
     if (!env) return default_value;
@@ -995,10 +1033,24 @@ static int fifo_prepare(char *fifo, int epoll_fd) {
     return fifo_fd;
 }
 
+static pthread_mutex_t mutex_patch_queue;
 
 static void* wf_patch_thread_entry(void *arg) {
-    char *fifo = getenv("WF_PATCH_TRIGGER_FIFO");
-    if (fifo == NULL) {
+    wf_set_group(wf_group_quiescence);
+
+    for(;;) {
+        pthread_mutex_lock(&mutex_patch_queue);
+        // No patch ready. Prevent from spurious wake
+        while (!(wf_patch_queue && *wf_patch_queue) ) {
+            pthread_cond_wait(&cond_trigger_patching, &mutex_patch_queue);
+        }
+        pthread_mutex_unlock(&mutex_patch_queue);
+        wf_trigger_patch();
+    }
+}
+
+static void* wf_patch_thread_entry2(void *arg) {
+    if (getenv("WF_PATCH_TRIGGER_FIFO") == NULL) {
         // Disable patching...
         wf_log("!!! PATCHING DISABLED !!!\n");
         return;
@@ -1009,7 +1061,7 @@ static void* wf_patch_thread_entry(void *arg) {
     int epoll_fd = epoll_create1(0);
     if (epoll_fd == -1) die("epoll_create");
 
-    int fifo_fd = fifo_prepare(fifo, epoll_fd);
+    int fifo_fd = fifo_prepare(getenv("WF_PATCH_TRIGGER_FIFO"), epoll_fd);
     
     // REDIS SPECIFICS:
     int latency_counter = 0;
@@ -1035,7 +1087,7 @@ static void* wf_patch_thread_entry(void *arg) {
                 buf[len] = 0;
                 int pte_size_kB = page_table_size(latency_counter);
                 if (strcmp(buf, "1") == 0) {
-                    wf_initiate_patching();
+                    wf_trigger_patch();
                 } else if (strcmp(buf, "2") == 0) {
                     // New AS every X seconds..
                     for(;;) {
@@ -1117,7 +1169,7 @@ close:
                 epoll_del(epoll_fd, fifo_fd);
                 close(fifo_fd);
 
-                fifo_fd = open_fifo(fifo);
+                fifo_fd = open_fifo(getenv("WF_PATCH_TRIGGER_FIFO"));
                 epoll_add(epoll_fd, fifo_fd, EPOLLIN);
             }
         }
@@ -1137,142 +1189,130 @@ static void wf_log_migrated() {
             wf_timestamp() - wf_timestamp_start_quiescence, wf_local_thread.current_as, wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id);
 }
 
-static void wf_initiate_patching(void) {
-    if (!wf_is_global_quiescence && wf_config_get("WF_LOCAL_SINGLE_AS", 0) != 0) {
-        // Do nothing; Local migration is handeled by wf_thread_birth.
-        return;
-    }
-
-    static int first = 0;
-    if (!first) first = 1;
-    else wf_log("---\n");
-   
-    // Print statistics about the current VMAs BEFORE time measurement starts 
-    count_vmas("before");
-
-    // Reset the time
-    wf_timestamp_reset();
-    
-    wf_log("- [apply, %ld.%09ld, %s, %d, \"%s\"]\n",
-           wf_ts0.tv_sec,
-           wf_ts0.tv_nsec,
-           wf_is_global_quiescence ? "global" : "local",
-           wf_amount_patching_threads(),
-           wf_local_thread.group->name
-        );
 
+void patch_global_quiescence() {
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    wf_local_thread.group->migrated_threads = 0;
 
-    wf_state = IDLE;
+    wf_timestamp_start_quiescence = wf_timestamp();
+    wf_state = IN_PROGRESS;
+    wf_local_thread.group->target_generation++;
 
-    if (wf_is_global_quiescence) {
-        pthread_mutex_lock(&wf_local_thread.group->mutex);
-        wf_local_thread.group->migrated_threads = 0;
-
-        wf_timestamp_start_quiescence = wf_timestamp();
-        wf_state = GLOBAL_QUIESCENCE;
-        wf_local_thread.group->target_generation++;
-
-        // Some Applications need a trigger to reach global quiescence
-        if (wf_config.trigger_global_quiescence) {
-            int trigger_counter = 0;
-            while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
-                pthread_mutex_unlock(&wf_local_thread.group->mutex);
-                if (wf_config.trigger_global_quiescence(trigger_counter++) == 0) {
-                    pthread_mutex_lock(&wf_local_thread.group->mutex);
-                    break;
-                }
-                msleep(wf_trigger_sleep_ms);
+    // Some Applications need a trigger to reach global quiescence
+    if (wf_config.trigger_global_quiescence) {
+        int trigger_counter = 0;
+        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
+            pthread_mutex_unlock(&wf_local_thread.group->mutex);
+            if (wf_config.trigger_global_quiescence(trigger_counter++) == 0) {
                 pthread_mutex_lock(&wf_local_thread.group->mutex);
+                break;
             }
+            msleep(wf_trigger_sleep_ms);
+            pthread_mutex_lock(&wf_local_thread.group->mutex);
         }
+    }
 
-        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
-            pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
-        ////////////////////////////////////////////////////////////////
-        wf_log("- [quiescence, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
+    while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
+        pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
+    ////////////////////////////////////////////////////////////////
+    wf_log("- [quiescence, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
 
-        // Load and Apply the patch
-        wf_load_patch();
+    // Load and Apply the patch
+    wf_load_patch();
 
-        wf_state = IDLE;
+    wf_state = IDLE;
+    ////////////////////////////////////////////////////////////////
+    // Let's leave the global quiescence point
+    wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
+    pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping threads
+    ////////////////////////////////////////////////////////////////
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+}
 
-        ////////////////////////////////////////////////////////////////
-        // Let's leave the global quiescence point
-        wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
-        pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping threads
-        ////////////////////////////////////////////////////////////////
-        pthread_mutex_unlock(&wf_local_thread.group->mutex);
-    } else {
-        double time_start_kernel_as_new = wf_timestamp();
-        int new_as = wf_kernel_as_new();
-        wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
+void patch_local_quiescence(void) {
+    double time_start_kernel_as_new = wf_timestamp();
+    int new_as = wf_kernel_as_new();
+    wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
 
-        double time_start_kernel_as_switch = wf_timestamp();
-        wf_kernel_as_switch(new_as);
-        wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
-        wf_local_thread.current_as = new_as;
+    double time_start_kernel_as_switch = wf_timestamp();
+    wf_kernel_as_switch(new_as);
+    wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
 
-        // Load and Apply the patch
-        wf_load_patch();
-        
-        pthread_mutex_lock(&wf_local_thread.group->mutex);
-        wf_local_thread.group->migrated_threads = 0;
-        wf_local_thread.group->previous_as = wf_local_thread.group->as;
-        wf_local_thread.group->as = new_as;
-        ////////////////////////////////////////////////////////////////
-        wf_timestamp_start_quiescence = wf_timestamp();
-        wf_state = LOCAL_QUIESCENCE;
-        wf_local_thread.group->target_generation++;
-
-        // Some applications require a trigger to reach local quiescence
-        if (wf_config.trigger_local_quiescence) {
-            int trigger_counter = 0;
-            while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
-                pthread_mutex_unlock(&wf_local_thread.group->mutex);
-                if (wf_config.trigger_local_quiescence(trigger_counter++) == 0) { 
-                    pthread_mutex_lock(&wf_local_thread.group->mutex);
-                    break;
-                }
-                msleep(wf_trigger_sleep_ms);
+    wf_local_thread.current_as = new_as;
+
+    // Load and Apply the patch
+    wf_load_patch();
+    
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    wf_local_thread.group->migrated_threads = 0;
+    wf_local_thread.group->previous_as = wf_local_thread.group->as;
+    wf_local_thread.group->as = new_as;
+    ////////////////////////////////////////////////////////////////
+    wf_timestamp_start_quiescence = wf_timestamp();
+    wf_state = IN_PROGRESS;
+    wf_local_thread.group->target_generation++;
+
+    // Some applications require a trigger to reach local quiescence
+    if (wf_config.trigger_local_quiescence) {
+        int trigger_counter = 0;
+        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
+            pthread_mutex_unlock(&wf_local_thread.group->mutex);
+            if (wf_config.trigger_local_quiescence(trigger_counter++) == 0) { 
                 pthread_mutex_lock(&wf_local_thread.group->mutex);
+                break;
             }
+            msleep(wf_trigger_sleep_ms);
+            pthread_mutex_lock(&wf_local_thread.group->mutex);
         }
-
-        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
-            pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
-        
-        if (wf_is_group_quiescence)
-            pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping group threads
-        
-        wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
-        // After successful migration of all threads, we try to delete
-        // the previous address-space generation
-        double time_wf_kernel_as_delete = wf_timestamp();
-        wf_kernel_as_delete(wf_local_thread.group->previous_as);
-        wf_log("- [address-space-delete, %.4f, \"%s\"]\n", wf_timestamp() - time_wf_kernel_as_delete, wf_local_thread.group->name);
-
-        wf_state = IDLE;
-        pthread_mutex_unlock(&wf_local_thread.group->mutex);
     }
 
-    log("%s Migration %d in %.4f for Group \"%s\"\n",
-        wf_is_global_quiescence ? "Global" : "Local",
-        wf_local_thread.group->target_generation,
-        wf_timestamp(),
-        wf_local_thread.group->name
-    );
+    while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
+        pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
+    
+    //if (wf_is_group_quiescence)
+        //pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping group threads
+    
+    wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
+    
+    // After successful migration of all threads, we try to delete
+    // the previous address-space generation
+    double time_wf_kernel_as_delete = wf_timestamp();
+    wf_kernel_as_delete(wf_local_thread.group->previous_as);
+    wf_log("- [address-space-delete, %.4f, \"%s\"]\n", wf_timestamp() - time_wf_kernel_as_delete, wf_local_thread.group->name);
 
+    wf_state = IDLE;
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+}
 
-    // Must be called in all circumstances as thread count could take
-    // a lock.
-    if (wf_config.patch_done) {
-        wf_config.patch_done();
-    }
+void wf_trigger_patch(void) {
+    static int first = 0;
+    if (!first) first = 1;
+    else wf_log("---\n");
+    
+    // Print statistics about the current VMAs BEFORE time measurement starts 
+    count_vmas("before");
+    page_table_size(first);
 
-    // Print statistics about VMAs again AFTER every thread has migrated
+    // Reset the time
+    wf_timestamp_reset();
+    
+    wf_log("- [apply, %ld.%09ld, %s, %d, \"%s\"]\n",
+           wf_ts0.tv_sec,
+           wf_ts0.tv_nsec,
+           get_patch_method_name(wf_patch_method),
+           wf_amount_patching_threads(),
+           wf_local_thread.group->name
+        );
+    
+    if (wf_patch_method == METHOD_GLOBAL) {
+        patch_global_quiescence();
+    } else if (wf_patch_method == METHOD_LOCAL) {
+        patch_local_quiescence();
+    }
     count_vmas("after");
 }
 
+
 bool check_if_quiescence() {
     if (wf_state == IDLE)
         return false;
@@ -1285,87 +1325,99 @@ bool check_if_quiescence() {
 }
 
 bool wf_allow_priority_quiescence();
-void wf_global_quiescence(void) {
-    if (!check_if_quiescence())
-        return;
-
-    // every global quiescence point is also an local quiescence point
-    if (!wf_is_global_quiescence) {
-        wf_local_quiescence();
-        return;
-    } 
-
-    if (wf_is_global_quiescence && wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
-        pthread_mutex_lock(&wf_local_thread.group->mutex);
-        if (!wf_allow_priority_quiescence()) {
-          pthread_mutex_unlock(&wf_local_thread.group->mutex);
-          return;
-        }
-        wf_log_reach_quiescence_point();
-        wf_local_thread.group->migrated_threads++;
-        wf_local_thread.in_global_quiescence = true;
-        wf_local_thread.current_generation = wf_local_thread.group->target_generation;
-        
-        // Scenario: GLOBAL_QUIESCENCE is performed while new threads are spawining.
-        // Patch application is performed and worker_thread releases lock. New threads 
-        // arrive here and wait for the signal, which will "never" arrive as patch application
-        // is already finished.
-        if (wf_state == GLOBAL_QUIESCENCE) {
-            // Signal that one thread has reached the barrier
-            if (wf_config.thread_migrated) {
-                int remaining = wf_amount_patching_threads() - wf_local_thread.group->migrated_threads;
-                wf_config.thread_migrated(remaining);
-            }
-            
-            if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads()) {
-                pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
-            }
-            // BLOCK: Wait for patcher thread to respond
-            pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
-            wf_local_thread.in_global_quiescence = false;
-        }
-        pthread_mutex_unlock(&wf_local_thread.group->mutex);
-    }
-}
+bool wf_quiescence(void) {
+    // Quiescence is always true because we do not apply any patches..
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) != 0)
+        return true;
 
-void wf_local_quiescence(void) {
     if (!check_if_quiescence())
-        return;
-    // Migrate as soon as a new version exists
-    if (!wf_is_global_quiescence && wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
-        pthread_mutex_lock(&wf_local_thread.group->mutex);
-        int as = wf_local_thread.group->as;
-        int target_generation = wf_local_thread.group->target_generation;
-        wf_local_thread.in_global_quiescence = true;
-        pthread_mutex_unlock(&wf_local_thread.group->mutex);
-
-        wf_log_reach_quiescence_point();
-        wf_kernel_as_switch(as);
-        wf_log_migrated();
-
-        pthread_mutex_lock(&wf_local_thread.group->mutex);
-        wf_local_thread.current_generation = target_generation;
-        wf_local_thread.current_as = as;
+        return false;
+    
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
 
-        wf_local_thread.group->migrated_threads++;
+    bool res = false;
+    if (wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
+        double start = wf_timestamp();
+        if (wf_patch_method == METHOD_GLOBAL)
+            res = wf_global_quiescence();
+        else if (wf_patch_method == METHOD_LOCAL)
+            res = wf_local_quiescence();
+        double end = wf_timestamp();
+        wf_log("- [e2e-patch, %ld.%09ld, %.4f, %d, \"%s\"]\n", ts.tv_sec, ts.tv_nsec, end - start, wf_patch_method, wf_local_thread.group->name);
+   }
+    return res;
+}
 
+bool wf_global_quiescence(void) {
+    // every global quiescence point is also an local quiescence point
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    if (!wf_allow_priority_quiescence()) {
+      pthread_mutex_unlock(&wf_local_thread.group->mutex);
+      return false;
+    }
+    wf_log_reach_quiescence_point();
+    wf_local_thread.group->migrated_threads++;
+    wf_local_thread.in_global_quiescence = true;
+    wf_local_thread.current_generation = wf_local_thread.group->target_generation;
+    
+    // Scenario: GLOBAL_QUIESCENCE is performed while new threads are spawining.
+    // Patch application is performed and worker_thread releases lock. New threads 
+    // arrive here and wait for the signal, which will "never" arrive as patch application
+    // is already finished.
+    if (wf_state != IDLE) {
+        // Signal that one thread has reached the barrier
         if (wf_config.thread_migrated) {
             int remaining = wf_amount_patching_threads() - wf_local_thread.group->migrated_threads;
-            // printf("remaining: %s %d\n", name, remaining);
             wf_config.thread_migrated(remaining);
         }
+        
         if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads()) {
-            // last thread; wakeup patcher thread
             pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
         }
-        
-        if (wf_is_group_quiescence) {
-            // Group quiescence is a form of global quiescence, but just for a group.
-            // So block the group and wait for all threads to be migrated
-            pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
-        }
-        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+        // BLOCK: Wait for patcher thread to respond
+        pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
+        wf_local_thread.in_global_quiescence = false;
+    }
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    return true;
+}
+
+bool wf_local_quiescence(void) {
+    // Migrate as soon as a new version exists
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    int as = wf_local_thread.group->as;
+    int target_generation = wf_local_thread.group->target_generation;
+    wf_local_thread.in_global_quiescence = true;
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+
+    wf_log_reach_quiescence_point();
+    wf_kernel_as_switch(as);
+    wf_log_migrated();
+
+    pthread_mutex_lock(&wf_local_thread.group->mutex);
+    wf_local_thread.current_generation = target_generation;
+    wf_local_thread.current_as = as;
+
+    wf_local_thread.group->migrated_threads++;
+
+    if (wf_config.thread_migrated) {
+        int remaining = wf_amount_patching_threads() - wf_local_thread.group->migrated_threads;
+        // printf("remaining: %s %d\n", name, remaining);
+        wf_config.thread_migrated(remaining);
+    }
+    if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads()) {
+        // last thread; wakeup patcher thread
+        pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
     }
+    
+    //if (wf_is_group_quiescence) {
+        // Group quiescence is a form of global quiescence, but just for a group.
+        // So block the group and wait for all threads to be migrated
+        //pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
+    //}
+    pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    return true;
 }
 
 #define OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED NULL
@@ -1393,19 +1445,6 @@ void wf_try_signal_thread_amount_changed(int amount_threads_added_removed) {
 /* Start of thread. SHould only be called once, otherwise use wf_thread_activate(). */
 void wf_thread_birth_group(char *name, char*group) {
     if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_START) {
-        // Special experiment; each thread has its own AS
-        if (!wf_is_global_quiescence && wf_config_get("WF_LOCAL_SINGLE_AS", 0) != 0) {
-            // Each thread should perform in its own AS
-            wf_log_reach_quiescence_point();
-
-            int as_id = wf_kernel_as_new();
-            wf_log("- [address-space-new, %.4f, \"%s\", \"%s\"]\n", wf_timestamp(), wf_local_thread.name, wf_local_thread.group->name);
-
-            wf_kernel_as_switch(as_id);
-            wf_local_thread.current_as = as_id;
-            wf_log_migrated();
-            return;
-        }
         wf_set_group(group);
 
         pthread_mutex_lock(&wf_local_thread.group->mutex);
@@ -1434,7 +1473,7 @@ void wf_thread_birth_group(char *name, char*group) {
 
         pthread_mutex_unlock(&wf_local_thread.group->mutex);
 
-        wf_global_quiescence();
+        wf_quiescence();
     } else {
 #ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
         wf_log("- [WARNING] Ignoring wf_thread_birth(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
@@ -1539,8 +1578,7 @@ int wf_find_lowest_priority(bool in_global_quiescence) {
 }
 
 bool wf_allow_priority_quiescence() {
-  if (wf_is_global_quiescence && wf_state != IDLE)
-  {
+  if (wf_state != IDLE) {
     // Quiescence in progress
     pthread_mutex_lock(&wf_all_threads_mutex);
     int lowest_priority_not_in_quiescence = wf_find_lowest_priority(false);
@@ -1576,6 +1614,24 @@ void wf_thread_set_priority(int priority) {
   pthread_mutex_unlock(&wf_local_thread.group->mutex);
 }
 
+void wf_set_patch(char *patch) {
+    if (patch) {
+        pthread_mutex_lock(&mutex_patch_queue);
+        wf_patch_queue = strdup(patch);
+        wf_log("- [Patch, \"%s\"]\n", wf_patch_queue);
+        pthread_mutex_unlock(&mutex_patch_queue);
+    }
+}
+
+void wf_set_patch_method(int method) {
+    if (method < 0 || method >= METHOD_TOTAL_METHODS) {
+        fprintf(stderr, "Invalid patch method used: %d!\n", method);
+        return;
+    }
+    wf_patch_method = method;
+    wf_log("- [PatchMethod, \"%s\"]\n", get_patch_method_name(method));
+}
+
 void wf_init(struct wf_configuration config) {
     wf_amount_priorities = config.amount_priorities;
     wf_trigger_sleep_ms = wf_config_get("WF_TRIGGER_SLEEP_MS", config.trigger_sleep_ms);
@@ -1584,27 +1640,26 @@ void wf_init(struct wf_configuration config) {
     wf_every_action_delay_ms = wf_config_get("WF_EVERY_ACTION_DELAY_MS", 0);
     latencies = calloc(1000, sizeof(struct patch_measurement));
 
-    int wf_global = wf_config_get("WF_GLOBAL", 1);
-    wf_is_global_quiescence = wf_global == 0 ? false : true;
+    wf_patch_method = wf_config_get("WF_PATCH_METHOD", 0);
    
     int wf_patch_only_active = wf_config_get("WF_PATCH_ONLY_ACTIVE", 0);
     wf_is_patch_only_active_threads = wf_patch_only_active == 0 ? false : true;
 
-    char *group_quiescence = getenv("WF_GROUP");
-    if (group_quiescence == NULL) {
-        wf_is_group_quiescence = false;
+    //char *group_quiescence = getenv("WF_GROUP");
+    //if (group_quiescence == NULL) {
+        //wf_is_group_quiescence = false;
+    //} else {
+        //wf_is_group_quiescence = true;
+        //wf_group_quiescence = group_quiescence;
+    //}
+    
+    if (wf_config_get("WF_SKIP_PATCH_APPLICATION", 0) != 0) {
+        // Do not load symbols if we don't want to patch. So we can also use a regular kernel ;-)
+        // On a regular kernel, this call fails otherwise
     } else {
-        wf_is_group_quiescence = true;
-        wf_group_quiescence = group_quiescence;
+        wf_load_symbols("/proc/self/exe");
     }
 
-    if (wf_is_global_quiescence && wf_is_group_quiescence) {
-        fprintf(stderr, "global quiescence is not possible with group quiescence!\n");
-        exit(1);
-    }
-
-    wf_load_symbols("/proc/self/exe");
-
     pthread_condattr_t attr;
     pthread_condattr_init(&attr);
     pthread_condattr_setclock(&attr, CLOCK_REALTIME);
@@ -1719,92 +1774,90 @@ static vma_count *count_vmas_find_vma_count(vma_count vma_count_list[], char *pe
  *  <sum SIZE>, <sum SHARED CLEAN>, <sum SHARED DIRTY>, <sum PRIVATE CLEAN>, <sum PRIVATE DIRTY>]
  * */
 static void count_vmas(char *output_suffix) {
-    const char* s = getenv("WF_MEASURE_VMA"); 
-    if (!s) return;
-
-    if (atoi(s) > 0) {
-        // Check VMA count
-        FILE *fp;
-        char *line = NULL;
-        size_t len = 0;
-        ssize_t read;
-
-        fp = fopen("/proc/self/smaps", "r");
-        if (fp == NULL) return;
-
-        vma_count vma_count_list[count_vmas_amount_perms * 2];
-        count_vmas_init_vma_count(vma_count_list);
-
-        char *const_size = "Size:";
-        char *const_shared_clean = "Shared_Clean:";
-        char *const_shared_dirty = "Shared_Dirty:";
-        char *const_private_clean = "Private_Clean:";
-        char *const_private_dirty = "Private_Dirty:";
-
-
-        regex_t header_regex;
-        int header_regex_result;
-        header_regex_result = regcomp(&header_regex, "^([0-9a-f]+-[0-9a-f]+) (....) ([0-9a-f]+) (..):(..) .*", REG_EXTENDED);
-        if (header_regex_result) {
-            fprintf(stderr, "Could not compile regex");
-            exit(1);
-        }
+    if (wf_config_get("WF_MEASURE_VMA", 0) == 0)
+        return;
 
-        vma_count *current_state = NULL;
-        while ((read = getline(&line, &len, fp)) != -1) {
-            header_regex_result = regexec(&header_regex, line, 0, NULL, 0);
-            if (!header_regex_result) {
-                strtok(line, " ");
-                char *perms = strtok(NULL, " "); // Permission
-                strtok(NULL, " "); // Offset
-                strtok(NULL, " "); // Time
-                char *inode = strtok(NULL, " "); // inode
-
-                current_state = count_vmas_find_vma_count(vma_count_list, perms, inode);
-                current_state->count += 1;
-            } else if (header_regex_result == REG_NOMATCH && current_state) {
-                strtok(line, " ");
-                if (strncmp(const_size, line, strlen(const_size)) == 0) {
-                    char *size = strtok(NULL, " ");
-                    int vma_size = atoi(size);
-                    current_state->size += vma_size;
-                } else if (strncmp(const_shared_clean, line, strlen(const_shared_clean)) == 0) {
-                    char *size = strtok(NULL, " ");
-                    int shared_clean = atoi(size);
-                    current_state->shared_clean += shared_clean; 
-                } else if (strncmp(const_shared_dirty, line, strlen(const_shared_dirty)) == 0) {
-                    char *size = strtok(NULL, " ");
-                    int shared_dirty = atoi(size);
-                    current_state->shared_dirty += shared_dirty;
-                } else if (strncmp(const_private_clean, line, strlen(const_private_clean)) == 0) {
-                    char *size = strtok(NULL, " ");
-                    int private_clean = atoi(size);
-                    current_state->private_clean += private_clean;
-                } else if (strncmp(const_private_dirty, line, strlen(const_private_dirty)) == 0) {
-                    char *size = strtok(NULL, " ");
-                    int private_dirty = atoi(size);
-                    current_state->private_dirty += private_dirty;
-                }
-            } else {
-                char msgbuf[100];
-                regerror(header_regex_result, &header_regex, msgbuf, sizeof(msgbuf));
-                fprintf(stderr, "Regex match failed: %s\n", msgbuf);
-                exit(1);
+    // Check VMA count
+    FILE *fp;
+    char *line = NULL;
+    size_t len = 0;
+    ssize_t read;
+
+    fp = fopen("/proc/self/smaps", "r");
+    if (fp == NULL) return;
+
+    vma_count vma_count_list[count_vmas_amount_perms * 2];
+    count_vmas_init_vma_count(vma_count_list);
+
+    char *const_size = "Size:";
+    char *const_shared_clean = "Shared_Clean:";
+    char *const_shared_dirty = "Shared_Dirty:";
+    char *const_private_clean = "Private_Clean:";
+    char *const_private_dirty = "Private_Dirty:";
+
+
+    regex_t header_regex;
+    int header_regex_result;
+    header_regex_result = regcomp(&header_regex, "^([0-9a-f]+-[0-9a-f]+) (....) ([0-9a-f]+) (..):(..) .*", REG_EXTENDED);
+    if (header_regex_result) {
+        fprintf(stderr, "Could not compile regex");
+        exit(1);
+    }
+
+    vma_count *current_state = NULL;
+    while ((read = getline(&line, &len, fp)) != -1) {
+        header_regex_result = regexec(&header_regex, line, 0, NULL, 0);
+        if (!header_regex_result) {
+            strtok(line, " ");
+            char *perms = strtok(NULL, " "); // Permission
+            strtok(NULL, " "); // Offset
+            strtok(NULL, " "); // Time
+            char *inode = strtok(NULL, " "); // inode
+
+            current_state = count_vmas_find_vma_count(vma_count_list, perms, inode);
+            current_state->count += 1;
+        } else if (header_regex_result == REG_NOMATCH && current_state) {
+            strtok(line, " ");
+            if (strncmp(const_size, line, strlen(const_size)) == 0) {
+                char *size = strtok(NULL, " ");
+                int vma_size = atoi(size);
+                current_state->size += vma_size;
+            } else if (strncmp(const_shared_clean, line, strlen(const_shared_clean)) == 0) {
+                char *size = strtok(NULL, " ");
+                int shared_clean = atoi(size);
+                current_state->shared_clean += shared_clean; 
+            } else if (strncmp(const_shared_dirty, line, strlen(const_shared_dirty)) == 0) {
+                char *size = strtok(NULL, " ");
+                int shared_dirty = atoi(size);
+                current_state->shared_dirty += shared_dirty;
+            } else if (strncmp(const_private_clean, line, strlen(const_private_clean)) == 0) {
+                char *size = strtok(NULL, " ");
+                int private_clean = atoi(size);
+                current_state->private_clean += private_clean;
+            } else if (strncmp(const_private_dirty, line, strlen(const_private_dirty)) == 0) {
+                char *size = strtok(NULL, " ");
+                int private_dirty = atoi(size);
+                current_state->private_dirty += private_dirty;
             }
+        } else {
+            char msgbuf[100];
+            regerror(header_regex_result, &header_regex, msgbuf, sizeof(msgbuf));
+            fprintf(stderr, "Regex match failed: %s\n", msgbuf);
+            exit(1);
         }
+    }
 
-        free(line);
-        fclose(fp);
+    free(line);
+    fclose(fp);
 
-        for (int i = 0; i < count_vmas_amount_perms * 2; i++) {
-            vma_count ele = vma_count_list[i];
+    for (int i = 0; i < count_vmas_amount_perms * 2; i++) {
+        vma_count ele = vma_count_list[i];
 
-            if (ele.count == 0) continue;
-            
-            wf_log("- [vma-count-%s, %d, %s, %s, %d, %d, %d, %d, %d, %d]\n",
-                    output_suffix, wf_local_thread.group == NULL ? 0: wf_local_thread.group->target_generation,
-                    ele.perms, ele.is_anon > 0 ? "ANONYMOUS": "FILE-BACKED", ele.count, ele.size, ele.shared_clean, ele.shared_dirty, ele.private_clean, ele.private_dirty);
-        }
+        if (ele.count == 0) continue;
+        
+        wf_log("- [vma-count-%s, %d, %s, %s, %d, %d, %d, %d, %d, %d]\n",
+                output_suffix, wf_local_thread.group == NULL ? 0: wf_local_thread.group->target_generation,
+                ele.perms, ele.is_anon > 0 ? "ANONYMOUS": "FILE-BACKED", ele.count, ele.size, ele.shared_clean, ele.shared_dirty, ele.private_clean, ele.private_dirty);
     }
 }
 
@@ -1819,8 +1872,8 @@ char *trim(char *str) {
 }
 
 int page_table_size(int iteration) {
-    const char* s = getenv("WF_MEASURE_PTE"); 
-    if (!s) return;
+     if (wf_config_get("WF_MEASURE_PTE", 0) == 0)
+        return;
 
     FILE *fp = fopen("/proc/self/status", "r");
     ssize_t read;
@@ -1832,7 +1885,7 @@ int page_table_size(int iteration) {
             line = trim(line);
             line[strlen(line) - strlen("kB")] = '\0';
             line = trim(line);
-            wf_log("[VmPTE %d, %s]\n", iteration, line);
+            wf_log("- [VmPTE-%d, %s]\n", iteration, line);
             return atoi(line);
         }
     }
diff --git a/src/wfpatch-userland/wf-userland.h b/src/wfpatch-userland/wf-userland.h
index 9a4640b94..fd3f836ce 100644
--- a/src/wfpatch-userland/wf-userland.h
+++ b/src/wfpatch-userland/wf-userland.h
@@ -44,35 +44,29 @@ struct wf_configuration {
 
 void wf_init(struct wf_configuration config);
 
-// The current thread has reached a global quiescence point. This
-// thread represents N morethreads (e.g. 16 pool workers). However,
-// the threads argument is purley for statistics. It does NOT
-// decrement the thread count by N but only by 1.
-//
-// The thread must invoke this repeatedly at every global quiesence
-// point.
-void wf_global_quiescence(void);
-
-// The current thread has reached a local quiescence point.
-// The thread must invoke this repeatedly
-void wf_local_quiescence(void);
-
-// Are we currently in the phase of a
-// bool wf_transition_ongoing(bool global);
-
-
-// Is a thread (that is counted in thread count), given birth to or
-// destroyed during a transition. The application must call these
-// functions, if config.track_threads=1.
+bool wf_quiescence(void);
+
+bool wf_local_quiescence(void);
+bool wf_global_quiescence(void);
+
+void wf_signal_patching(void);
+void wf_trigger_patch(void);
+
+//void wf_thread_birth_group(char *name, char *group);
 void wf_thread_birth(char *name);
-void wf_thread_birth_group(char *name, char *group);
-void wf_thread_activate(void);
 void wf_thread_death(void);
-void wf_thread_deactivate(void);
+
 void wf_thread_set_priority(int priority);
 
+void wf_thread_activate(void);
+void wf_thread_deactivate(void);
+
 int wf_get_local_thread_id();
-bool wf_is_quiescence();
+void wf_set_patch(char *patch);
+void wf_set_patch_method(int method);
+
+void wf_log(char *fmt, ...);
+double wf_time(void);
 
 #ifdef __cplusplus
 }
